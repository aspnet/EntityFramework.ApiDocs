<Type Name="PropertyBuilder&lt;TProperty&gt;" FullName="Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt;">
  <TypeSignature Language="C#" Value="public class PropertyBuilder&lt;TProperty&gt; : Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PropertyBuilder`1&lt;TProperty&gt; extends Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder" />
  <TypeSignature Language="DocId" Value="T:Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1" />
  <TypeSignature Language="VB.NET" Value="Public Class PropertyBuilder(Of TProperty)&#xA;Inherits PropertyBuilder" />
  <TypeSignature Language="F#" Value="type PropertyBuilder&lt;'Property&gt; = class&#xA;    inherit PropertyBuilder" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
    <AssemblyVersion>1.0.0.0</AssemblyVersion>
    <AssemblyVersion>1.1.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TProperty" />
  </TypeParameters>
  <Base>
    <BaseTypeName>Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <typeparam name="TProperty">To be added.</typeparam>
    <summary>
      <para>
                    Provides a simple API for configuring a <see cref="T:Microsoft.EntityFrameworkCore.Metadata.Internal.Property" />.
                </para>
      <para>
                    Instances of this class are returned from methods when using the <see cref="T:Microsoft.EntityFrameworkCore.ModelBuilder" /> API
                    and it is not designed to be directly constructed in your application code.
                </para>
    </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyBuilder (Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1.#ctor(Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (builder As InternalPropertyBuilder)" />
      <MemberSignature Language="F#" Value="new Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;'Property&gt; : Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;'Property&gt;" Usage="new Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;'Property&gt; builder" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="builder" Type="Microsoft.EntityFrameworkCore.Metadata.Internal.InternalPropertyBuilder" />
      </Parameters>
      <Docs>
        <param name="builder">To be added.</param>
        <summary>
                This API supports the Entity Framework Core infrastructure and is not intended to be used
                directly from your code. This API may change or be removed in future releases.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAnnotation">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt; HasAnnotation (string annotation, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1&lt;!TProperty&gt; HasAnnotation(string annotation, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1.HasAnnotation(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasAnnotation (annotation As String, value As Object) As PropertyBuilder(Of TProperty)" />
      <MemberSignature Language="F#" Value="override this.HasAnnotation : string * obj -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;'Property&gt;" Usage="propertyBuilder.HasAnnotation (annotation, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="annotation" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="annotation"> The key of the annotation to be added or updated. </param>
        <param name="value"> The value to be stored in the annotation. </param>
        <summary>
                Adds or updates an annotation on the property. If an annotation with the key specified in
                <paramref name="annotation" /> already exists its value will be updated.
            </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasConversion">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt; HasConversion (Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter converter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1&lt;!TProperty&gt; HasConversion(class Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1.HasConversion(Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasConversion (converter As ValueConverter) As PropertyBuilder(Of TProperty)" />
      <MemberSignature Language="F#" Value="override this.HasConversion : Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;'Property&gt;" Usage="propertyBuilder.HasConversion converter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="converter" Type="Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter" />
      </Parameters>
      <Docs>
        <param name="converter"> The converter to use. </param>
        <summary>
                Configures the property so that the property value is converted to and from the database
                using the given <see cref="T:Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter" />.
            </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasConversion">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt; HasConversion (Type providerClrType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1&lt;!TProperty&gt; HasConversion(class System.Type providerClrType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1.HasConversion(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasConversion (providerClrType As Type) As PropertyBuilder(Of TProperty)" />
      <MemberSignature Language="F#" Value="override this.HasConversion : Type -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;'Property&gt;" Usage="propertyBuilder.HasConversion providerClrType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="providerClrType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="providerClrType"> The type to convert to and from. </param>
        <summary>
                Configures the property so that the property value is converted to the given type before
                writing to the database and converted back when reading from the database.
            </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasConversion&lt;TProvider&gt;">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt; HasConversion&lt;TProvider&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1&lt;!TProperty&gt; HasConversion&lt;TProvider&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1.HasConversion``1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasConversion(Of TProvider) () As PropertyBuilder(Of TProperty)" />
      <MemberSignature Language="F#" Value="override this.HasConversion : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;'Property&gt;" Usage="propertyBuilder.HasConversion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TProvider" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TProvider"> The type to convert to and from. </typeparam>
        <summary>
                Configures the property so that the property value is converted to the given type before
                writing to the database and converted back when reading from the database.
            </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasConversion&lt;TProvider&gt;">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt; HasConversion&lt;TProvider&gt; (Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter&lt;TProperty,TProvider&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1&lt;!TProperty&gt; HasConversion&lt;TProvider&gt;(class Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter`2&lt;!TProperty, !!TProvider&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1.HasConversion``1(Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter{`0,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasConversion(Of TProvider) (converter As ValueConverter(Of TProperty, TProvider)) As PropertyBuilder(Of TProperty)" />
      <MemberSignature Language="F#" Value="override this.HasConversion : Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter&lt;'Property, 'Provider&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;'Property&gt;" Usage="propertyBuilder.HasConversion converter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TProvider" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="converter" Type="Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter&lt;TProperty,TProvider&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TProvider"> The store type generated by the converter. </typeparam>
        <param name="converter"> The converter to use. </param>
        <summary>
                Configures the property so that the property value is converted to and from the database
                using the given <see cref="T:Microsoft.EntityFrameworkCore.Storage.ValueConversion.ValueConverter`2" />.
            </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasConversion&lt;TProvider&gt;">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt; HasConversion&lt;TProvider&gt; (System.Linq.Expressions.Expression&lt;Func&lt;TProperty,TProvider&gt;&gt; convertToProviderExpression, System.Linq.Expressions.Expression&lt;Func&lt;TProvider,TProperty&gt;&gt; convertFromProviderExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1&lt;!TProperty&gt; HasConversion&lt;TProvider&gt;(class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!TProperty, !!TProvider&gt;&gt; convertToProviderExpression, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TProvider, !TProperty&gt;&gt; convertFromProviderExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1.HasConversion``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Linq.Expressions.Expression{System.Func{``0,`0}})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasConversion(Of TProvider) (convertToProviderExpression As Expression(Of Func(Of TProperty, TProvider)), convertFromProviderExpression As Expression(Of Func(Of TProvider, TProperty))) As PropertyBuilder(Of TProperty)" />
      <MemberSignature Language="F#" Value="override this.HasConversion : System.Linq.Expressions.Expression&lt;Func&lt;'Property, 'Provider&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Provider, 'Property&gt;&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;'Property&gt;" Usage="propertyBuilder.HasConversion (convertToProviderExpression, convertFromProviderExpression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TProvider" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="convertToProviderExpression" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TProperty,TProvider&gt;&gt;" />
        <Parameter Name="convertFromProviderExpression" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TProvider,TProperty&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TProvider"> The store type generated by the conversions. </typeparam>
        <param name="convertToProviderExpression"> An expression to convert objects when writing data to the store. </param>
        <param name="convertFromProviderExpression"> An expression to convert objects when reading data from the store. </param>
        <summary>
                Configures the property so that the property value is converted to and from the database
                using the given conversion expressions.
            </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasField">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt; HasField (string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1&lt;!TProperty&gt; HasField(string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1.HasField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasField (fieldName As String) As PropertyBuilder(Of TProperty)" />
      <MemberSignature Language="F#" Value="override this.HasField : string -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;'Property&gt;" Usage="propertyBuilder.HasField fieldName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fieldName"> The field name. </param>
        <summary>
          <para>
                    Sets the backing field to use for this property.
                </para>
          <para>
                    Backing fields are normally found by convention as described
                    here: http://go.microsoft.com/fwlink/?LinkId=723277.
                    This method is useful for setting backing fields explicitly in cases where the
                    correct field is not found by convention.
                </para>
          <para>
                    By default, the backing field, if one is found or has been specified, is used when
                    new objects are constructed, typically when entities are queried from the database.
                    Properties are used for all other accesses. This can be changed by calling
                    <see cref="M:Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1.UsePropertyAccessMode(Microsoft.EntityFrameworkCore.PropertyAccessMode)" />.
                </para>
        </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasMaxLength">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt; HasMaxLength (int maxLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1&lt;!TProperty&gt; HasMaxLength(int32 maxLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1.HasMaxLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasMaxLength (maxLength As Integer) As PropertyBuilder(Of TProperty)" />
      <MemberSignature Language="F#" Value="override this.HasMaxLength : int -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;'Property&gt;" Usage="propertyBuilder.HasMaxLength maxLength" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxLength"> The maximum length of data allowed in the property. </param>
        <summary>
                Configures the maximum length of data that can be stored in this property.
                Maximum length can only be set on array properties (including <see cref="T:System.String" /> properties).
            </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasValueGenerator">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt; HasValueGenerator (Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.IEntityType,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; factory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1&lt;!TProperty&gt; HasValueGenerator(class System.Func`3&lt;class Microsoft.EntityFrameworkCore.Metadata.IProperty, class Microsoft.EntityFrameworkCore.Metadata.IEntityType, class Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; factory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1.HasValueGenerator(System.Func{Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.IEntityType,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasValueGenerator (factory As Func(Of IProperty, IEntityType, ValueGenerator)) As PropertyBuilder(Of TProperty)" />
      <MemberSignature Language="F#" Value="override this.HasValueGenerator : Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty, Microsoft.EntityFrameworkCore.Metadata.IEntityType, Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt; -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;'Property&gt;" Usage="propertyBuilder.HasValueGenerator factory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factory" Type="System.Func&lt;Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.IEntityType,Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator&gt;" />
      </Parameters>
      <Docs>
        <param name="factory"> A delegate that will be used to create value generator instances. </param>
        <summary>
          <para>
                    Configures a factory for creating a <see cref="T:Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator" /> to use to generate values
                    for this property.
                </para>
          <para>
                    Values are generated when the entity is added to the context using, for example,
                    <see cref="M:Microsoft.EntityFrameworkCore.DbContext.Add``1(``0)" />. Values are generated only when the property is assigned
                    the CLR default value (null for string, 0 for int, Guid.Empty for Guid, etc.).
                </para>
          <para>
                    This factory will be invoked once to create a single instance of the value generator, and
                    this will be used to generate values for this property in all instances of the entity type.
                </para>
          <para>
                    This method is intended for use with custom value generation. Value generation for common cases is
                    usually handled automatically by the database provider.
                </para>
        </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasValueGenerator">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt; HasValueGenerator (Type valueGeneratorType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1&lt;!TProperty&gt; HasValueGenerator(class System.Type valueGeneratorType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1.HasValueGenerator(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasValueGenerator (valueGeneratorType As Type) As PropertyBuilder(Of TProperty)" />
      <MemberSignature Language="F#" Value="override this.HasValueGenerator : Type -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;'Property&gt;" Usage="propertyBuilder.HasValueGenerator valueGeneratorType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="valueGeneratorType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="valueGeneratorType"> A type that inherits from <see cref="T:Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator" /></param>
        <summary>
          <para>
                    Configures the <see cref="T:Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator" /> that will generate values for this property.
                </para>
          <para>
                    Values are generated when the entity is added to the context using, for example,
                    <see cref="M:Microsoft.EntityFrameworkCore.DbContext.Add``1(``0)" />. Values are generated only when the property is assigned
                    the CLR default value (null for string, 0 for int, Guid.Empty for Guid, etc.).
                </para>
          <para>
                    A single instance of this type will be created and used to generate values for this property in all
                    instances of the entity type. The type must be instantiable and have a parameterless constructor.
                </para>
          <para>
                    This method is intended for use with custom value generation. Value generation for common cases is
                    usually handled automatically by the database provider.
                </para>
          <para>
                    Setting null does not disable value generation for this property, it just clears any generator explicitly
                    configured for this property. The database provider may still have a value generator for the property type.
                </para>
        </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasValueGenerator&lt;TGenerator&gt;">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt; HasValueGenerator&lt;TGenerator&gt; () where TGenerator : Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1&lt;!TProperty&gt; HasValueGenerator&lt;(class Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator) TGenerator&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1.HasValueGenerator``1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasValueGenerator(Of TGenerator As ValueGenerator) () As PropertyBuilder(Of TProperty)" />
      <MemberSignature Language="F#" Value="override this.HasValueGenerator : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;'Property&gt; (requires 'Generator :&gt; Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator)" Usage="propertyBuilder.HasValueGenerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TGenerator">
          <Constraints>
            <BaseTypeName>Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TGenerator">To be added.</typeparam>
        <summary>
          <para>
                    Configures the <see cref="T:Microsoft.EntityFrameworkCore.ValueGeneration.ValueGenerator" /> that will generate values for this property.
                </para>
          <para>
                    Values are generated when the entity is added to the context using, for example,
                    <see cref="M:Microsoft.EntityFrameworkCore.DbContext.Add``1(``0)" />. Values are generated only when the property is assigned
                    the CLR default value (null for string, 0 for int, Guid.Empty for Guid, etc.).
                </para>
          <para>
                    A single instance of this type will be created and used to generate values for this property in all
                    instances of the entity type. The type must be instantiable and have a parameterless constructor.
                </para>
          <para>
                    This method is intended for use with custom value generation. Value generation for common cases is
                    usually handled automatically by the database provider.
                </para>
        </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConcurrencyToken">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt; IsConcurrencyToken (bool concurrencyToken = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1&lt;!TProperty&gt; IsConcurrencyToken(bool concurrencyToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1.IsConcurrencyToken(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsConcurrencyToken (Optional concurrencyToken As Boolean = true) As PropertyBuilder(Of TProperty)" />
      <MemberSignature Language="F#" Value="override this.IsConcurrencyToken : bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;'Property&gt;" Usage="propertyBuilder.IsConcurrencyToken concurrencyToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="concurrencyToken" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="concurrencyToken"> A value indicating whether this property is a concurrency token. </param>
        <summary>
                Configures whether this property should be used as a concurrency token. When a property is configured
                as a concurrency token the value in the database will be checked when an instance of this entity type
                is updated or deleted during <see cref="M:Microsoft.EntityFrameworkCore.DbContext.SaveChanges" /> to ensure it has not changed since
                the instance was retrieved from the database. If it has changed, an exception will be thrown and the
                changes will not be applied to the database.
            </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRequired">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt; IsRequired (bool required = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1&lt;!TProperty&gt; IsRequired(bool required) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1.IsRequired(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsRequired (Optional required As Boolean = true) As PropertyBuilder(Of TProperty)" />
      <MemberSignature Language="F#" Value="override this.IsRequired : bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;'Property&gt;" Usage="propertyBuilder.IsRequired required" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="required" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="required"> A value indicating whether the property is required. </param>
        <summary>
                Configures whether this property must have a value assigned or whether null is a valid value.
                A property can only be configured as non-required if it is based on a CLR type that can be
                assigned null.
            </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRowVersion">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt; IsRowVersion ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1&lt;!TProperty&gt; IsRowVersion() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1.IsRowVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsRowVersion () As PropertyBuilder(Of TProperty)" />
      <MemberSignature Language="F#" Value="override this.IsRowVersion : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;'Property&gt;" Usage="propertyBuilder.IsRowVersion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>
                    Configures the property as <see cref="M:Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1.ValueGeneratedOnAddOrUpdate" /> and
                    <see cref="M:Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1.IsConcurrencyToken(System.Boolean)" />.
                </para>
          <para>
                    Database providers can choose to interpret this in different way, but it is commonly used
                    to indicate some form of automatic row-versioning as used for optimistic concurrency detection.
                </para>
        </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicode">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt; IsUnicode (bool unicode = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1&lt;!TProperty&gt; IsUnicode(bool unicode) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1.IsUnicode(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsUnicode (Optional unicode As Boolean = true) As PropertyBuilder(Of TProperty)" />
      <MemberSignature Language="F#" Value="override this.IsUnicode : bool -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;'Property&gt;" Usage="propertyBuilder.IsUnicode unicode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unicode" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="unicode"> A value indicating whether the property can contain unicode characters or not. </param>
        <summary>
                Configures the property as capable of persisting unicode characters or not.
                Can only be set on <see cref="T:System.String" /> properties.
            </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UsePropertyAccessMode">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt; UsePropertyAccessMode (Microsoft.EntityFrameworkCore.Metadata.PropertyAccessMode propertyAccessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1&lt;!TProperty&gt; UsePropertyAccessMode(valuetype Microsoft.EntityFrameworkCore.Metadata.PropertyAccessMode propertyAccessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1.UsePropertyAccessMode(Microsoft.EntityFrameworkCore.Metadata.PropertyAccessMode)" />
      <MemberSignature Language="F#" Value="override this.UsePropertyAccessMode : Microsoft.EntityFrameworkCore.Metadata.PropertyAccessMode -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;'Property&gt;" Usage="propertyBuilder.UsePropertyAccessMode propertyAccessMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessMode" Type="Microsoft.EntityFrameworkCore.Metadata.PropertyAccessMode" />
      </Parameters>
      <Docs>
        <param name="propertyAccessMode"> The <see cref="T:Microsoft.EntityFrameworkCore.Metadata.PropertyAccessMode" /> to use for this property. </param>
        <summary>
          <para>
                    Sets the <see cref="T:Microsoft.EntityFrameworkCore.Metadata.PropertyAccessMode" /> to use for this property.
                </para>
          <para>
                    By default, the backing field, if one is found by convention or has been specified, is used when
                    new objects are constructed, typically when entities are queried from the database.
                    Properties are used for all other accesses.  Calling this method will change that behavior
                    for this property as described in the <see cref="T:Microsoft.EntityFrameworkCore.Metadata.PropertyAccessMode" /> enum.
                </para>
          <para>
                    Calling this method overrides for this property any access mode that was set on the
                    entity type or model.
                </para>
        </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UsePropertyAccessMode">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt; UsePropertyAccessMode (Microsoft.EntityFrameworkCore.PropertyAccessMode propertyAccessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1&lt;!TProperty&gt; UsePropertyAccessMode(valuetype Microsoft.EntityFrameworkCore.PropertyAccessMode propertyAccessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1.UsePropertyAccessMode(Microsoft.EntityFrameworkCore.PropertyAccessMode)" />
      <MemberSignature Language="F#" Value="override this.UsePropertyAccessMode : Microsoft.EntityFrameworkCore.PropertyAccessMode -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;'Property&gt;" Usage="propertyBuilder.UsePropertyAccessMode propertyAccessMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyAccessMode" Type="Microsoft.EntityFrameworkCore.PropertyAccessMode" />
      </Parameters>
      <Docs>
        <param name="propertyAccessMode"> The <see cref="T:Microsoft.EntityFrameworkCore.PropertyAccessMode" /> to use for this property. </param>
        <summary>
          <para>
                    Sets the <see cref="T:Microsoft.EntityFrameworkCore.PropertyAccessMode" /> to use for this property.
                </para>
          <para>
                    By default, the backing field, if one is found by convention or has been specified, is used when
                    new objects are constructed, typically when entities are queried from the database.
                    Properties are used for all other accesses.  Calling this method will change that behavior
                    for this property as described in the <see cref="T:Microsoft.EntityFrameworkCore.PropertyAccessMode" /> enum.
                </para>
          <para>
                    Calling this method overrides for this property any access mode that was set on the
                    entity type or model.
                </para>
        </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueGeneratedNever">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt; ValueGeneratedNever ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1&lt;!TProperty&gt; ValueGeneratedNever() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1.ValueGeneratedNever" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ValueGeneratedNever () As PropertyBuilder(Of TProperty)" />
      <MemberSignature Language="F#" Value="override this.ValueGeneratedNever : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;'Property&gt;" Usage="propertyBuilder.ValueGeneratedNever " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Configures a property to never have a value generated when an instance of this
                entity type is saved.
            </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>
                Note that temporary values may still be generated for use internally before a
                new entity is saved.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueGeneratedOnAdd">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt; ValueGeneratedOnAdd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1&lt;!TProperty&gt; ValueGeneratedOnAdd() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1.ValueGeneratedOnAdd" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ValueGeneratedOnAdd () As PropertyBuilder(Of TProperty)" />
      <MemberSignature Language="F#" Value="override this.ValueGeneratedOnAdd : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;'Property&gt;" Usage="propertyBuilder.ValueGeneratedOnAdd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Configures a property to have a value generated only when saving a new entity, unless a non-null,
                non-temporary value has been set, in which case the set value will be saved instead. The value
                may be generated by a client-side value generator or may be generated by the database as part
                of saving the entity.
            </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueGeneratedOnAddOrUpdate">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt; ValueGeneratedOnAddOrUpdate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1&lt;!TProperty&gt; ValueGeneratedOnAddOrUpdate() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1.ValueGeneratedOnAddOrUpdate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ValueGeneratedOnAddOrUpdate () As PropertyBuilder(Of TProperty)" />
      <MemberSignature Language="F#" Value="override this.ValueGeneratedOnAddOrUpdate : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;'Property&gt;" Usage="propertyBuilder.ValueGeneratedOnAddOrUpdate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
        <AssemblyVersion>1.1.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Configures a property to have a value generated when saving a new or existing entity.
            </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueGeneratedOnUpdate">
      <MemberSignature Language="C#" Value="public virtual Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt; ValueGeneratedOnUpdate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1&lt;!TProperty&gt; ValueGeneratedOnUpdate() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder`1.ValueGeneratedOnUpdate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ValueGeneratedOnUpdate () As PropertyBuilder(Of TProperty)" />
      <MemberSignature Language="F#" Value="override this.ValueGeneratedOnUpdate : unit -&gt; Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;'Property&gt;" Usage="propertyBuilder.ValueGeneratedOnUpdate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.EntityFrameworkCore</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.EntityFrameworkCore.Metadata.Builders.PropertyBuilder&lt;TProperty&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
                Configures a property to have a value generated when saving an existing entity.
            </summary>
        <returns> The same builder instance so that multiple configuration calls can be chained. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>