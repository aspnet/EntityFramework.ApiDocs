<Type Name="ObjectContext" FullName="System.Data.Entity.Core.Objects.ObjectContext">
  <TypeSignature Language="C#" Value="public class ObjectContext : IDisposable, System.Data.Entity.Infrastructure.IObjectContextAdapter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ObjectContext extends System.Object implements class System.Data.Entity.Infrastructure.IObjectContextAdapter, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Data.Entity.Core.Objects.ObjectContext" />
  <TypeSignature Language="VB.NET" Value="Public Class ObjectContext&#xA;Implements IDisposable, IObjectContextAdapter" />
  <TypeSignature Language="F#" Value="type ObjectContext = class&#xA;    interface IDisposable&#xA;    interface IObjectContextAdapter" />
  <AssemblyInfo>
    <AssemblyName>EntityFramework</AssemblyName>
    <AssemblyVersion>6.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Data.Entity.Infrastructure.IObjectContextAdapter</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
            ObjectContext is the top-level object that encapsulates a connection between the CLR and the database,
            serving as a gateway for Create, Read, Update, and Delete operations.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ObjectContext (System.Data.Entity.Core.EntityClient.EntityConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.Entity.Core.EntityClient.EntityConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.#ctor(System.Data.Entity.Core.EntityClient.EntityConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connection As EntityConnection)" />
      <MemberSignature Language="F#" Value="new System.Data.Entity.Core.Objects.ObjectContext : System.Data.Entity.Core.EntityClient.EntityConnection -&gt; System.Data.Entity.Core.Objects.ObjectContext" Usage="new System.Data.Entity.Core.Objects.ObjectContext connection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.Entity.Core.EntityClient.EntityConnection" />
      </Parameters>
      <Docs>
        <param name="connection">
            An <see cref="T:System.Data.Entity.Core.EntityClient.EntityConnection" /> that contains references to the model and to the data source connection.
            </param>
        <summary>
            Initializes a new instance of the <see cref="T:System.Data.Entity.Core.Objects.ObjectContext" /> class with the given connection. During construction, the metadata workspace is extracted from the
            <see cref="T:System.Data.Entity.Core.EntityClient.EntityConnection" />
            object.
            </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">The  connection  is null.</exception>
        <exception cref="T:System.ArgumentException">The  connection  is invalid or the metadata workspace is invalid. </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ObjectContext (string connectionString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string connectionString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connectionString As String)" />
      <MemberSignature Language="F#" Value="new System.Data.Entity.Core.Objects.ObjectContext : string -&gt; System.Data.Entity.Core.Objects.ObjectContext" Usage="new System.Data.Entity.Core.Objects.ObjectContext connectionString" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification="Object is in fact passed to property of the class and gets Disposed properly in the Dispose() method.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="connectionString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="connectionString">The connection string, which also provides access to the metadata information.</param>
        <summary>
            Initializes a new instance of the <see cref="T:System.Data.Entity.Core.Objects.ObjectContext" /> class with the given connection string and default entity container name.
            </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">The  connectionString  is null.</exception>
        <exception cref="T:System.ArgumentException">The  connectionString  is invalid or the metadata workspace is not valid. </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ObjectContext (System.Data.Entity.Core.EntityClient.EntityConnection connection, bool contextOwnsConnection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.Entity.Core.EntityClient.EntityConnection connection, bool contextOwnsConnection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.#ctor(System.Data.Entity.Core.EntityClient.EntityConnection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connection As EntityConnection, contextOwnsConnection As Boolean)" />
      <MemberSignature Language="F#" Value="new System.Data.Entity.Core.Objects.ObjectContext : System.Data.Entity.Core.EntityClient.EntityConnection * bool -&gt; System.Data.Entity.Core.Objects.ObjectContext" Usage="new System.Data.Entity.Core.Objects.ObjectContext (connection, contextOwnsConnection)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.Entity.Core.EntityClient.EntityConnection" />
        <Parameter Name="contextOwnsConnection" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="connection"> connection to the store </param>
        <param name="contextOwnsConnection"> If set to true the connection is disposed when the context is disposed, otherwise the caller must dispose the connection. </param>
        <summary>
            Creates an ObjectContext with the given connection and metadata workspace.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ObjectContext (System.Data.Entity.Core.EntityClient.EntityConnection connection, string defaultContainerName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Data.Entity.Core.EntityClient.EntityConnection connection, string defaultContainerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.#ctor(System.Data.Entity.Core.EntityClient.EntityConnection,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (connection As EntityConnection, defaultContainerName As String)" />
      <MemberSignature Language="F#" Value="new System.Data.Entity.Core.Objects.ObjectContext : System.Data.Entity.Core.EntityClient.EntityConnection * string -&gt; System.Data.Entity.Core.Objects.ObjectContext" Usage="new System.Data.Entity.Core.Objects.ObjectContext (connection, defaultContainerName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2214:DoNotCallOverridableMethodsInConstructors", Justification="Class is internal and methods are made virtual for testing purposes only. They cannot be overridden by user.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.Entity.Core.EntityClient.EntityConnection" />
        <Parameter Name="defaultContainerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="connection">
            An <see cref="T:System.Data.Entity.Core.EntityClient.EntityConnection" /> that contains references to the model and to the data source connection.
            </param>
        <param name="defaultContainerName">The name of the default entity container. When the  defaultContainerName  is set through this method, the property becomes read-only.</param>
        <summary>
            Initializes a new instance of the <see cref="T:System.Data.Entity.Core.Objects.ObjectContext" /> class with a given connection and entity container name.
            </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">The  connection  is null.</exception>
        <exception cref="T:System.ArgumentException">The  connection ,  defaultContainerName , or metadata workspace is not valid.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ObjectContext (string connectionString, string defaultContainerName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string connectionString, string defaultContainerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (connectionString As String, defaultContainerName As String)" />
      <MemberSignature Language="F#" Value="new System.Data.Entity.Core.Objects.ObjectContext : string * string -&gt; System.Data.Entity.Core.Objects.ObjectContext" Usage="new System.Data.Entity.Core.Objects.ObjectContext (connectionString, defaultContainerName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2214:DoNotCallOverridableMethodsInConstructors", Justification="Class is internal and methods are made virtual for testing purposes only. They cannot be overridden by user.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="connectionString" Type="System.String" />
        <Parameter Name="defaultContainerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="connectionString">The connection string, which also provides access to the metadata information.</param>
        <param name="defaultContainerName">The name of the default entity container. When the  defaultContainerName  is set through this method, the property becomes read-only.</param>
        <summary>
            Initializes a new instance of the <see cref="T:System.Data.Entity.Core.Objects.ObjectContext" /> class with a given connection string and entity container name.
            </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">The  connectionString  is null.</exception>
        <exception cref="T:System.ArgumentException">The  connectionString ,  defaultContainerName , or metadata workspace is not valid.</exception>
      </Docs>
    </Member>
    <Member MemberName="AcceptAllChanges">
      <MemberSignature Language="C#" Value="public virtual void AcceptAllChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AcceptAllChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.AcceptAllChanges" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AcceptAllChanges ()" />
      <MemberSignature Language="F#" Value="abstract member AcceptAllChanges : unit -&gt; unit&#xA;override this.AcceptAllChanges : unit -&gt; unit" Usage="objectContext.AcceptAllChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Accepts all changes made to objects in the object context.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddObject">
      <MemberSignature Language="C#" Value="public virtual void AddObject (string entitySetName, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddObject(string entitySetName, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.AddObject(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AddObject (entitySetName As String, entity As Object)" />
      <MemberSignature Language="F#" Value="abstract member AddObject : string * obj -&gt; unit&#xA;override this.AddObject : string * obj -&gt; unit" Usage="objectContext.AddObject (entitySetName, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">Represents the entity set name, which may optionally be qualified by the entity container name. </param>
        <param name="entity">
            The <see cref="T:System.Object" /> to add.
            </param>
        <summary>Adds an object to the object context. </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">The  entity  parameter is null or the  entitySetName  does not qualify.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplyCurrentValues&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public virtual TEntity ApplyCurrentValues&lt;TEntity&gt; (string entitySetName, TEntity currentEntity) where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance !!TEntity ApplyCurrentValues&lt;class TEntity&gt;(string entitySetName, !!TEntity currentEntity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.ApplyCurrentValues``1(System.String,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ApplyCurrentValues(Of TEntity As Class) (entitySetName As String, currentEntity As TEntity) As TEntity" />
      <MemberSignature Language="F#" Value="abstract member ApplyCurrentValues : string * 'Entity -&gt; 'Entity (requires 'Entity : null)&#xA;override this.ApplyCurrentValues : string * 'Entity -&gt; 'Entity (requires 'Entity : null)" Usage="objectContext.ApplyCurrentValues (entitySetName, currentEntity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TEntity</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="currentEntity" Type="TEntity" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">The entity type of the object.</typeparam>
        <param name="entitySetName">The name of the entity set to which the object belongs.</param>
        <param name="currentEntity">
            The detached object that has property updates to apply to the original object. The entity key of  currentEntity  must match the
            <see cref="P:System.Data.Entity.Core.Objects.ObjectStateEntry.EntityKey" />
            property of an entry in the
            <see cref="T:System.Data.Entity.Core.Objects.ObjectContext" />
            .
            </param>
        <summary>
            Copies the scalar values from the supplied object into the object in the
            <see cref="T:System.Data.Entity.Core.Objects.ObjectContext" />
            that has the same key.
            </summary>
        <returns>The updated object.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"> entitySetName  or  current  is null.</exception>
        <exception cref="T:System.InvalidOperationException">
            The <see cref="T:System.Data.Entity.Core.Metadata.Edm.EntitySet" /> from  entitySetName  does not match the
            <see cref="T:System.Data.Entity.Core.Metadata.Edm.EntitySet" />
            of the object
            <see cref="T:System.Data.Entity.Core.EntityKey" />
             or the object is not in the
            <see cref="T:System.Data.Entity.Core.Objects.ObjectStateManager" />
            or it is in a
            <see cref="F:System.Data.Entity.EntityState.Detached" />
            state or the entity key of the supplied object is invalid.
            </exception>
        <exception cref="T:System.ArgumentException"> entitySetName  is an empty string.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplyOriginalValues&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public virtual TEntity ApplyOriginalValues&lt;TEntity&gt; (string entitySetName, TEntity originalEntity) where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance !!TEntity ApplyOriginalValues&lt;class TEntity&gt;(string entitySetName, !!TEntity originalEntity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.ApplyOriginalValues``1(System.String,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ApplyOriginalValues(Of TEntity As Class) (entitySetName As String, originalEntity As TEntity) As TEntity" />
      <MemberSignature Language="F#" Value="abstract member ApplyOriginalValues : string * 'Entity -&gt; 'Entity (requires 'Entity : null)&#xA;override this.ApplyOriginalValues : string * 'Entity -&gt; 'Entity (requires 'Entity : null)" Usage="objectContext.ApplyOriginalValues (entitySetName, originalEntity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TEntity</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="originalEntity" Type="TEntity" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">The type of the entity object.</typeparam>
        <param name="entitySetName">The name of the entity set to which the object belongs.</param>
        <param name="originalEntity">
            The detached object that has original values to apply to the object. The entity key of  originalEntity  must match the
            <see cref="P:System.Data.Entity.Core.Objects.ObjectStateEntry.EntityKey" />
            property of an entry in the
            <see cref="T:System.Data.Entity.Core.Objects.ObjectContext" />
            .
            </param>
        <summary>
            Copies the scalar values from the supplied object into set of original values for the object in the
            <see cref="T:System.Data.Entity.Core.Objects.ObjectContext" />
            that has the same key.
            </summary>
        <returns>The updated object.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"> entitySetName  or  original  is null.</exception>
        <exception cref="T:System.InvalidOperationException">
            The <see cref="T:System.Data.Entity.Core.Metadata.Edm.EntitySet" /> from  entitySetName  does not match the
            <see cref="T:System.Data.Entity.Core.Metadata.Edm.EntitySet" />
            of the object
            <see cref="T:System.Data.Entity.Core.EntityKey" />
             or an
            <see cref="T:System.Data.Entity.Core.Objects.ObjectStateEntry" />
            for the object cannot be found in the
            <see cref="T:System.Data.Entity.Core.Objects.ObjectStateManager" />
             or the object is in an
            <see cref="F:System.Data.Entity.EntityState.Added" />
            or a
            <see cref="F:System.Data.Entity.EntityState.Detached" />
            state  or the entity key of the supplied object is invalid or has property changes.
            </exception>
        <exception cref="T:System.ArgumentException"> entitySetName  is an empty string.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplyPropertyChanges">
      <MemberSignature Language="C#" Value="public virtual void ApplyPropertyChanges (string entitySetName, object changed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyPropertyChanges(string entitySetName, object changed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.ApplyPropertyChanges(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ApplyPropertyChanges (entitySetName As String, changed As Object)" />
      <MemberSignature Language="F#" Value="abstract member ApplyPropertyChanges : string * obj -&gt; unit&#xA;override this.ApplyPropertyChanges : string * obj -&gt; unit" Usage="objectContext.ApplyPropertyChanges (entitySetName, changed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use ApplyCurrentValues instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="changed" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">The name of the entity set to which the object belongs.</param>
        <param name="changed">The detached object that has property updates to apply to the original object.</param>
        <summary>Applies property changes from a detached object to an object already attached to the object context.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">When  entitySetName  is null or an empty string or when  changed  is null.</exception>
        <exception cref="T:System.InvalidOperationException">
            When the <see cref="T:System.Data.Entity.Core.Metadata.Edm.EntitySet" /> from  entitySetName  does not match the
            <see cref="T:System.Data.Entity.Core.Metadata.Edm.EntitySet" />
            of the object
            <see cref="T:System.Data.Entity.Core.EntityKey" />
            or when the entity is in a state other than
            <see cref="F:System.Data.Entity.EntityState.Modified" />
            or
            <see cref="F:System.Data.Entity.EntityState.Unchanged" />
            or the original object is not attached to the context.
            </exception>
        <exception cref="T:System.ArgumentException">When the type of the  changed  object is not the same type as the original object.</exception>
      </Docs>
    </Member>
    <Member MemberName="Attach">
      <MemberSignature Language="C#" Value="public virtual void Attach (System.Data.Entity.Core.Objects.DataClasses.IEntityWithKey entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Attach(class System.Data.Entity.Core.Objects.DataClasses.IEntityWithKey entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.Attach(System.Data.Entity.Core.Objects.DataClasses.IEntityWithKey)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Attach (entity As IEntityWithKey)" />
      <MemberSignature Language="F#" Value="abstract member Attach : System.Data.Entity.Core.Objects.DataClasses.IEntityWithKey -&gt; unit&#xA;override this.Attach : System.Data.Entity.Core.Objects.DataClasses.IEntityWithKey -&gt; unit" Usage="objectContext.Attach entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Data.Entity.Core.Objects.DataClasses.IEntityWithKey" />
      </Parameters>
      <Docs>
        <param name="entity">The object to attach.</param>
        <summary>Attaches an object or object graph to the object context when the object has an entity key. </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">The  entity  is null. </exception>
        <exception cref="T:System.InvalidOperationException">Invalid entity key. </exception>
      </Docs>
    </Member>
    <Member MemberName="AttachTo">
      <MemberSignature Language="C#" Value="public virtual void AttachTo (string entitySetName, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AttachTo(string entitySetName, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.AttachTo(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AttachTo (entitySetName As String, entity As Object)" />
      <MemberSignature Language="F#" Value="abstract member AttachTo : string * obj -&gt; unit&#xA;override this.AttachTo : string * obj -&gt; unit" Usage="objectContext.AttachTo (entitySetName, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">Represents the entity set name, which may optionally be qualified by the entity container name. </param>
        <param name="entity">
            The <see cref="T:System.Object" /> to attach.
            </param>
        <summary>Attaches an object or object graph to the object context in a specific entity set. </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">The  entity  is null. </exception>
        <exception cref="T:System.InvalidOperationException">
            Invalid entity set  or the object has a temporary key or the object has an
            <see cref="T:System.Data.Entity.Core.EntityKey" />
            and the
            <see cref="T:System.Data.Entity.Core.Metadata.Edm.EntitySet" />
            does not match with the entity set passed in as an argument of the method or the object does not have an
            <see cref="T:System.Data.Entity.Core.EntityKey" />
            and no entity set is provided or any object from the object graph has a temporary
            <see cref="T:System.Data.Entity.Core.EntityKey" />
             or any object from the object graph has an invalid
            <see cref="T:System.Data.Entity.Core.EntityKey" />
            (for example, values in the key do not match values in the object) or the entity set could not be found from a given  entitySetName  name and entity container name or any object from the object graph already exists in another state manager.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="CommandTimeout">
      <MemberSignature Language="C#" Value="public virtual Nullable&lt;int&gt; CommandTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;int32&gt; CommandTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.Entity.Core.Objects.ObjectContext.CommandTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CommandTimeout As Nullable(Of Integer)" />
      <MemberSignature Language="F#" Value="member this.CommandTimeout : Nullable&lt;int&gt; with get, set" Usage="System.Data.Entity.Core.Objects.ObjectContext.CommandTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the timeout value, in seconds, for all object context operations. A null value indicates that the default value of the underlying provider will be used.</summary>
        <value>
            An <see cref="T:System.Int32" /> value that is the timeout value, in seconds.
            </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">The timeout value is less than 0. </exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public virtual System.Data.Common.DbConnection Connection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbConnection Connection" />
      <MemberSignature Language="DocId" Value="P:System.Data.Entity.Core.Objects.ObjectContext.Connection" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Connection As DbConnection" />
      <MemberSignature Language="F#" Value="member this.Connection : System.Data.Common.DbConnection" Usage="System.Data.Entity.Core.Objects.ObjectContext.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbConnection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the connection used by the object context.</summary>
        <value>
            A <see cref="T:System.Data.Common.DbConnection" /> object that is the connection.
            </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
            When the <see cref="T:System.Data.Entity.Core.Objects.ObjectContext" /> instance has been disposed.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="ContextOptions">
      <MemberSignature Language="C#" Value="public virtual System.Data.Entity.Core.Objects.ObjectContextOptions ContextOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Entity.Core.Objects.ObjectContextOptions ContextOptions" />
      <MemberSignature Language="DocId" Value="P:System.Data.Entity.Core.Objects.ObjectContext.ContextOptions" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContextOptions As ObjectContextOptions" />
      <MemberSignature Language="F#" Value="member this.ContextOptions : System.Data.Entity.Core.Objects.ObjectContextOptions" Usage="System.Data.Entity.Core.Objects.ObjectContext.ContextOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Entity.Core.Objects.ObjectContextOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the <see cref="T:System.Data.Entity.Core.Objects.ObjectContextOptions" /> instance that contains options that affect the behavior of the
            <see cref="T:System.Data.Entity.Core.Objects.ObjectContext" />
            .
            </summary>
        <value>
            The <see cref="T:System.Data.Entity.Core.Objects.ObjectContextOptions" /> instance that contains options that affect the behavior of the
            <see cref="T:System.Data.Entity.Core.Objects.ObjectContext" />
            .
            </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDatabase">
      <MemberSignature Language="C#" Value="public virtual void CreateDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.CreateDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub CreateDatabase ()" />
      <MemberSignature Language="F#" Value="abstract member CreateDatabase : unit -&gt; unit&#xA;override this.CreateDatabase : unit -&gt; unit" Usage="objectContext.CreateDatabase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Creates the database by using the current data source connection and the metadata in the
            <see cref="T:System.Data.Entity.Core.Metadata.Edm.StoreItemCollection" />
            .
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDatabaseScript">
      <MemberSignature Language="C#" Value="public virtual string CreateDatabaseScript ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CreateDatabaseScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.CreateDatabaseScript" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateDatabaseScript () As String" />
      <MemberSignature Language="F#" Value="abstract member CreateDatabaseScript : unit -&gt; string&#xA;override this.CreateDatabaseScript : unit -&gt; string" Usage="objectContext.CreateDatabaseScript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Generates a data definition language (DDL) script that creates schema objects (tables, primary keys, foreign keys) for the metadata in the
            <see cref="T:System.Data.Entity.Core.Metadata.Edm.StoreItemCollection" />
            . The
            <see cref="T:System.Data.Entity.Core.Metadata.Edm.StoreItemCollection" />
            loads metadata from store schema definition language (SSDL) files.
            </summary>
        <returns>
            A DDL script that creates schema objects for the metadata in the
            <see cref="T:System.Data.Entity.Core.Metadata.Edm.StoreItemCollection" />
            .
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateEntityKey">
      <MemberSignature Language="C#" Value="public virtual System.Data.Entity.Core.EntityKey CreateEntityKey (string entitySetName, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.Entity.Core.EntityKey CreateEntityKey(string entitySetName, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.CreateEntityKey(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateEntityKey (entitySetName As String, entity As Object) As EntityKey" />
      <MemberSignature Language="F#" Value="abstract member CreateEntityKey : string * obj -&gt; System.Data.Entity.Core.EntityKey&#xA;override this.CreateEntityKey : string * obj -&gt; System.Data.Entity.Core.EntityKey" Usage="objectContext.CreateEntityKey (entitySetName, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Entity.Core.EntityKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">The fully qualified name of the entity set to which the entity object belongs.</param>
        <param name="entity">The object for which the entity key is being retrieved. </param>
        <summary>Creates the entity key for a specific object, or returns the entity key if it already exists. </summary>
        <returns>
            The <see cref="T:System.Data.Entity.Core.EntityKey" /> of the object.
            </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">When either parameter is null. </exception>
        <exception cref="T:System.ArgumentException">When  entitySetName  is empty or when the type of the  entity  object does not exist in the entity set or when the  entitySetName  is not fully qualified.</exception>
        <exception cref="T:System.InvalidOperationException">When the entity key cannot be constructed successfully based on the supplied parameters.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateObject&lt;T&gt;">
      <MemberSignature Language="C#" Value="public virtual T CreateObject&lt;T&gt; () where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance !!T CreateObject&lt;class T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.CreateObject``1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateObject(Of T As Class) () As T" />
      <MemberSignature Language="F#" Value="abstract member CreateObject : unit -&gt; 'T (requires 'T : null)&#xA;override this.CreateObject : unit -&gt; 'T (requires 'T : null)" Usage="objectContext.CreateObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Type of object to be returned.</typeparam>
        <summary>Creates and returns an instance of the requested type .</summary>
        <returns>An instance of the requested type  T , or an instance of a derived type that enables  T  to be used with the Entity Framework. The returned object is either an instance of the requested type or an instance of a derived type that enables the requested type to be used with the Entity Framework.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObjectSet&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public virtual System.Data.Entity.Core.Objects.ObjectSet&lt;TEntity&gt; CreateObjectSet&lt;TEntity&gt; () where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.Entity.Core.Objects.ObjectSet`1&lt;!!TEntity&gt; CreateObjectSet&lt;class TEntity&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.CreateObjectSet``1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateObjectSet(Of TEntity As Class) () As ObjectSet(Of TEntity)" />
      <MemberSignature Language="F#" Value="abstract member CreateObjectSet : unit -&gt; System.Data.Entity.Core.Objects.ObjectSet&lt;'Entity (requires 'Entity : null)&gt; (requires 'Entity : null)&#xA;override this.CreateObjectSet : unit -&gt; System.Data.Entity.Core.Objects.ObjectSet&lt;'Entity (requires 'Entity : null)&gt; (requires 'Entity : null)" Usage="objectContext.CreateObjectSet " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Entity.Core.Objects.ObjectSet&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TEntity">
            Entity type of the requested <see cref="T:System.Data.Entity.Core.Objects.ObjectSet`1" />.
            </typeparam>
        <summary>
            Creates a new <see cref="T:System.Data.Entity.Core.Objects.ObjectSet`1" /> instance that is used to query, add, modify, and delete objects of the specified entity type.
            </summary>
        <returns>
            The new <see cref="T:System.Data.Entity.Core.Objects.ObjectSet`1" /> instance.
            </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">
            The <see cref="P:System.Data.Entity.Core.Objects.ObjectContext.DefaultContainerName" /> property is not set on the
            <see cref="T:System.Data.Entity.Core.Objects.ObjectContext" />
             or the specified type belongs to more than one entity set.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="CreateObjectSet&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public virtual System.Data.Entity.Core.Objects.ObjectSet&lt;TEntity&gt; CreateObjectSet&lt;TEntity&gt; (string entitySetName) where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.Entity.Core.Objects.ObjectSet`1&lt;!!TEntity&gt; CreateObjectSet&lt;class TEntity&gt;(string entitySetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.CreateObjectSet``1(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateObjectSet(Of TEntity As Class) (entitySetName As String) As ObjectSet(Of TEntity)" />
      <MemberSignature Language="F#" Value="abstract member CreateObjectSet : string -&gt; System.Data.Entity.Core.Objects.ObjectSet&lt;'Entity (requires 'Entity : null)&gt; (requires 'Entity : null)&#xA;override this.CreateObjectSet : string -&gt; System.Data.Entity.Core.Objects.ObjectSet&lt;'Entity (requires 'Entity : null)&gt; (requires 'Entity : null)" Usage="objectContext.CreateObjectSet entitySetName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Entity.Core.Objects.ObjectSet&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">
            Entity type of the requested <see cref="T:System.Data.Entity.Core.Objects.ObjectSet`1" />.
            </typeparam>
        <param name="entitySetName">
            Name of the entity set for the returned <see cref="T:System.Data.Entity.Core.Objects.ObjectSet`1" />. The string must be qualified by the default container name if the
            <see cref="P:System.Data.Entity.Core.Objects.ObjectContext.DefaultContainerName" />
            property is not set on the
            <see cref="T:System.Data.Entity.Core.Objects.ObjectContext" />
            .
            </param>
        <summary>
            Creates a new <see cref="T:System.Data.Entity.Core.Objects.ObjectSet`1" /> instance that is used to query, add, modify, and delete objects of the specified type and with the specified entity set name.
            </summary>
        <returns>
            The new <see cref="T:System.Data.Entity.Core.Objects.ObjectSet`1" /> instance.
            </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">
            The <see cref="T:System.Data.Entity.Core.Metadata.Edm.EntitySet" /> from  entitySetName  does not match the
            <see cref="T:System.Data.Entity.Core.Metadata.Edm.EntitySet" />
            of the object
            <see cref="T:System.Data.Entity.Core.EntityKey" />
             or the
            <see cref="P:System.Data.Entity.Core.Objects.ObjectContext.DefaultContainerName" />
            property is not set on the
            <see cref="T:System.Data.Entity.Core.Objects.ObjectContext" />
            and the name is not qualified as part of the  entitySetName  parameter or the specified type belongs to more than one entity set.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="CreateProxyTypes">
      <MemberSignature Language="C#" Value="public virtual void CreateProxyTypes (System.Collections.Generic.IEnumerable&lt;Type&gt; types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateProxyTypes(class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.CreateProxyTypes(System.Collections.Generic.IEnumerable{System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub CreateProxyTypes (types As IEnumerable(Of Type))" />
      <MemberSignature Language="F#" Value="abstract member CreateProxyTypes : seq&lt;Type&gt; -&gt; unit&#xA;override this.CreateProxyTypes : seq&lt;Type&gt; -&gt; unit" Usage="objectContext.CreateProxyTypes types" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Collections.Generic.IEnumerable&lt;System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="types">
            An enumeration of <see cref="T:System.Type" /> objects that represent custom data classes that map to the conceptual model.
            </param>
        <summary>Generates an equivalent type that can be used with the Entity Framework for each type in the supplied enumeration.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateQuery&lt;T&gt;">
      <MemberSignature Language="C#" Value="public virtual System.Data.Entity.Core.Objects.ObjectQuery&lt;T&gt; CreateQuery&lt;T&gt; (string queryString, params System.Data.Entity.Core.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.Entity.Core.Objects.ObjectQuery`1&lt;!!T&gt; CreateQuery&lt;T&gt;(string queryString, class System.Data.Entity.Core.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.CreateQuery``1(System.String,System.Data.Entity.Core.Objects.ObjectParameter[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateQuery(Of T) (queryString As String, ParamArray parameters As ObjectParameter()) As ObjectQuery(Of T)" />
      <MemberSignature Language="F#" Value="abstract member CreateQuery : string * System.Data.Entity.Core.Objects.ObjectParameter[] -&gt; System.Data.Entity.Core.Objects.ObjectQuery&lt;'T&gt;&#xA;override this.CreateQuery : string * System.Data.Entity.Core.Objects.ObjectParameter[] -&gt; System.Data.Entity.Core.Objects.ObjectQuery&lt;'T&gt;" Usage="objectContext.CreateQuery (queryString, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Entity.Core.Objects.ObjectQuery&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="queryString" Type="System.String" />
        <Parameter Name="parameters" Type="System.Data.Entity.Core.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">
            The entity type of the returned <see cref="T:System.Data.Entity.Core.Objects.ObjectQuery`1" />.
            </typeparam>
        <param name="queryString">The query string to be executed.</param>
        <param name="parameters">Parameters to pass to the query.</param>
        <summary>
            Creates an <see cref="T:System.Data.Entity.Core.Objects.ObjectQuery`1" /> in the current object context by using the specified query string.
            </summary>
        <returns>
            An <see cref="T:System.Data.Entity.Core.Objects.ObjectQuery`1" /> of the specified type.
            </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">The  queryString  or  parameters  parameter is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="DatabaseExists">
      <MemberSignature Language="C#" Value="public virtual bool DatabaseExists ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool DatabaseExists() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.DatabaseExists" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DatabaseExists () As Boolean" />
      <MemberSignature Language="F#" Value="abstract member DatabaseExists : unit -&gt; bool&#xA;override this.DatabaseExists : unit -&gt; bool" Usage="objectContext.DatabaseExists " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Checks if the database that is specified as the database in the current store connection exists on the store. Most of the actual work
            is done by the DbProviderServices implementation for the current store connection.
            </summary>
        <returns>true if the database exists; otherwise, false.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultContainerName">
      <MemberSignature Language="C#" Value="public virtual string DefaultContainerName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DefaultContainerName" />
      <MemberSignature Language="DocId" Value="P:System.Data.Entity.Core.Objects.ObjectContext.DefaultContainerName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DefaultContainerName As String" />
      <MemberSignature Language="F#" Value="member this.DefaultContainerName : string with get, set" Usage="System.Data.Entity.Core.Objects.ObjectContext.DefaultContainerName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the default container name.</summary>
        <value>
            A <see cref="T:System.String" /> that is the default container name.
            </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteDatabase">
      <MemberSignature Language="C#" Value="public virtual void DeleteDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.DeleteDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DeleteDatabase ()" />
      <MemberSignature Language="F#" Value="abstract member DeleteDatabase : unit -&gt; unit&#xA;override this.DeleteDatabase : unit -&gt; unit" Usage="objectContext.DeleteDatabase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Deletes the database that is specified as the database in the current data source connection.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteObject">
      <MemberSignature Language="C#" Value="public virtual void DeleteObject (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteObject(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.DeleteObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DeleteObject (entity As Object)" />
      <MemberSignature Language="F#" Value="abstract member DeleteObject : obj -&gt; unit&#xA;override this.DeleteObject : obj -&gt; unit" Usage="objectContext.DeleteObject entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">
            An object that specifies the entity to delete. The object can be in any state except
            <see cref="F:System.Data.Entity.EntityState.Detached" />
            .
            </param>
        <summary>Marks an object for deletion. </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Detach">
      <MemberSignature Language="C#" Value="public virtual void Detach (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Detach(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.Detach(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Detach (entity As Object)" />
      <MemberSignature Language="F#" Value="abstract member Detach : obj -&gt; unit&#xA;override this.Detach : obj -&gt; unit" Usage="objectContext.Detach entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">
            Object to be detached. Only the  entity  is removed; if there are any related objects that are being tracked by the same
            <see cref="T:System.Data.Entity.Core.Objects.ObjectStateManager" />
            , those will not be detached automatically.
            </param>
        <summary>Removes the object from the object context.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">The  entity  is null. </exception>
        <exception cref="T:System.InvalidOperationException">
            The  entity  is not associated with this <see cref="T:System.Data.Entity.Core.Objects.ObjectContext" /> (for example, was newly created and not associated with any context yet, or was obtained through some other context, or was already detached).
            </exception>
      </Docs>
    </Member>
    <Member MemberName="DetectChanges">
      <MemberSignature Language="C#" Value="public virtual void DetectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DetectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.DetectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DetectChanges ()" />
      <MemberSignature Language="F#" Value="abstract member DetectChanges : unit -&gt; unit&#xA;override this.DetectChanges : unit -&gt; unit" Usage="objectContext.DetectChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Ensures that <see cref="T:System.Data.Entity.Core.Objects.ObjectStateEntry" /> changes are synchronized with changes in all objects that are tracked by the
            <see cref="T:System.Data.Entity.Core.Objects.ObjectStateManager" />
            .
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="objectContext.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1063:ImplementIDisposableCorrectly")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases the resources used by the object context.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="objectContext.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.
            </param>
        <summary>
            Releases the resources used by the object context.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteFunction">
      <MemberSignature Language="C#" Value="public virtual int ExecuteFunction (string functionName, params System.Data.Entity.Core.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteFunction(string functionName, class System.Data.Entity.Core.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.ExecuteFunction(System.String,System.Data.Entity.Core.Objects.ObjectParameter[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ExecuteFunction (functionName As String, ParamArray parameters As ObjectParameter()) As Integer" />
      <MemberSignature Language="F#" Value="abstract member ExecuteFunction : string * System.Data.Entity.Core.Objects.ObjectParameter[] -&gt; int&#xA;override this.ExecuteFunction : string * System.Data.Entity.Core.Objects.ObjectParameter[] -&gt; int" Usage="objectContext.ExecuteFunction (functionName, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
        <Parameter Name="parameters" Type="System.Data.Entity.Core.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="functionName">The name of the stored procedure or function. The name can include the container name, such as &lt;Container Name&gt;.&lt;Function Name&gt;. When the default container name is known, only the function name is required.</param>
        <param name="parameters">
            An array of <see cref="T:System.Data.Entity.Core.Objects.ObjectParameter" /> objects. If output parameters are used, 
            their values will not be available until the results have been read completely. This is due to the underlying 
            behavior of DbDataReader, see http://go.microsoft.com/fwlink/?LinkID=398589 for more details.
            </param>
        <summary>Executes a stored procedure or function that is defined in the data source and expressed in the conceptual model; discards any results returned from the function; and returns the number of rows affected by the execution.</summary>
        <returns>The number of rows affected.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"> function  is null or empty or function  is not found.</exception>
        <exception cref="T:System.InvalidOperationException">The entity reader does not support this  function or there is a type mismatch on the reader and the  function .</exception>
      </Docs>
    </Member>
    <Member MemberName="ExecuteFunction&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Entity.Core.Objects.ObjectResult&lt;TElement&gt; ExecuteFunction&lt;TElement&gt; (string functionName, params System.Data.Entity.Core.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Entity.Core.Objects.ObjectResult`1&lt;!!TElement&gt; ExecuteFunction&lt;TElement&gt;(string functionName, class System.Data.Entity.Core.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.ExecuteFunction``1(System.String,System.Data.Entity.Core.Objects.ObjectParameter[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteFunction(Of TElement) (functionName As String, ParamArray parameters As ObjectParameter()) As ObjectResult(Of TElement)" />
      <MemberSignature Language="F#" Value="member this.ExecuteFunction : string * System.Data.Entity.Core.Objects.ObjectParameter[] -&gt; System.Data.Entity.Core.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.ExecuteFunction (functionName, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Entity.Core.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
        <Parameter Name="parameters" Type="System.Data.Entity.Core.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement">
            The entity type of the <see cref="T:System.Data.Entity.Core.Objects.ObjectResult`1" /> returned when the function is executed against the data source. This type must implement
            <see cref="T:System.Data.Entity.Core.Objects.DataClasses.IEntityWithChangeTracker" />
            .
            </typeparam>
        <param name="functionName">The name of the stored procedure or function. The name can include the container name, such as &lt;Container Name&gt;.&lt;Function Name&gt;. When the default container name is known, only the function name is required.</param>
        <param name="parameters">
            An array of <see cref="T:System.Data.Entity.Core.Objects.ObjectParameter" /> objects. If output parameters are used, 
            their values will not be available until the results have been read completely. This is due to the underlying behavior 
            of DbDataReader, see http://go.microsoft.com/fwlink/?LinkID=398589 for more details.
            </param>
        <summary>
            Executes a stored procedure or function that is defined in the data source and mapped in the conceptual model, with the specified parameters. Returns a typed
            <see cref="T:System.Data.Entity.Core.Objects.ObjectResult`1" />
            .
            </summary>
        <returns>
            An <see cref="T:System.Data.Entity.Core.Objects.ObjectResult`1" /> for the data that is returned by the stored procedure.
            </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"> function  is null or empty or function  is not found.</exception>
        <exception cref="T:System.InvalidOperationException">The entity reader does not support this  function or there is a type mismatch on the reader and the  function .</exception>
      </Docs>
    </Member>
    <Member MemberName="ExecuteFunction&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public virtual System.Data.Entity.Core.Objects.ObjectResult&lt;TElement&gt; ExecuteFunction&lt;TElement&gt; (string functionName, System.Data.Entity.Core.Objects.ExecutionOptions executionOptions, params System.Data.Entity.Core.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.Entity.Core.Objects.ObjectResult`1&lt;!!TElement&gt; ExecuteFunction&lt;TElement&gt;(string functionName, class System.Data.Entity.Core.Objects.ExecutionOptions executionOptions, class System.Data.Entity.Core.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.ExecuteFunction``1(System.String,System.Data.Entity.Core.Objects.ExecutionOptions,System.Data.Entity.Core.Objects.ObjectParameter[])" />
      <MemberSignature Language="F#" Value="abstract member ExecuteFunction : string * System.Data.Entity.Core.Objects.ExecutionOptions * System.Data.Entity.Core.Objects.ObjectParameter[] -&gt; System.Data.Entity.Core.Objects.ObjectResult&lt;'Element&gt;&#xA;override this.ExecuteFunction : string * System.Data.Entity.Core.Objects.ExecutionOptions * System.Data.Entity.Core.Objects.ObjectParameter[] -&gt; System.Data.Entity.Core.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.ExecuteFunction (functionName, executionOptions, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Entity.Core.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
        <Parameter Name="executionOptions" Type="System.Data.Entity.Core.Objects.ExecutionOptions" />
        <Parameter Name="parameters" Type="System.Data.Entity.Core.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement"> Element type for function results. </typeparam>
        <param name="functionName">
            Name of function. May include container (e.g. ContainerName.FunctionName) or just function name when DefaultContainerName is known.
            </param>
        <param name="executionOptions"> The options for executing this function. </param>
        <param name="parameters"> 
            The parameter values to use for the function. If output parameters are used, their values 
            will not be available until the results have been read completely. This is due to the underlying 
            behavior of DbDataReader, see http://go.microsoft.com/fwlink/?LinkID=398589 for more details.
            </param>
        <summary>
            Executes the given function on the default container.
            </summary>
        <returns>An object representing the result of executing this function.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"> If function is null or empty </exception>
        <exception cref="T:System.InvalidOperationException">
            If function is invalid (syntax,
            does not exist, refers to a function with return type incompatible with T)
            </exception>
      </Docs>
    </Member>
    <Member MemberName="ExecuteFunction&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public virtual System.Data.Entity.Core.Objects.ObjectResult&lt;TElement&gt; ExecuteFunction&lt;TElement&gt; (string functionName, System.Data.Entity.Core.Objects.MergeOption mergeOption, params System.Data.Entity.Core.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.Entity.Core.Objects.ObjectResult`1&lt;!!TElement&gt; ExecuteFunction&lt;TElement&gt;(string functionName, valuetype System.Data.Entity.Core.Objects.MergeOption mergeOption, class System.Data.Entity.Core.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.ExecuteFunction``1(System.String,System.Data.Entity.Core.Objects.MergeOption,System.Data.Entity.Core.Objects.ObjectParameter[])" />
      <MemberSignature Language="F#" Value="abstract member ExecuteFunction : string * System.Data.Entity.Core.Objects.MergeOption * System.Data.Entity.Core.Objects.ObjectParameter[] -&gt; System.Data.Entity.Core.Objects.ObjectResult&lt;'Element&gt;&#xA;override this.ExecuteFunction : string * System.Data.Entity.Core.Objects.MergeOption * System.Data.Entity.Core.Objects.ObjectParameter[] -&gt; System.Data.Entity.Core.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.ExecuteFunction (functionName, mergeOption, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Entity.Core.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
        <Parameter Name="mergeOption" Type="System.Data.Entity.Core.Objects.MergeOption" />
        <Parameter Name="parameters" Type="System.Data.Entity.Core.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement">
            The entity type of the <see cref="T:System.Data.Entity.Core.Objects.ObjectResult`1" /> returned when the function is executed against the data source. This type must implement
            <see cref="T:System.Data.Entity.Core.Objects.DataClasses.IEntityWithChangeTracker" />
            .
            </typeparam>
        <param name="functionName">The name of the stored procedure or function. The name can include the container name, such as &lt;Container Name&gt;.&lt;Function Name&gt;. When the default container name is known, only the function name is required.</param>
        <param name="mergeOption">
            The <see cref="T:System.Data.Entity.Core.Objects.MergeOption" /> to use when executing the query.
            </param>
        <param name="parameters">
            An array of <see cref="T:System.Data.Entity.Core.Objects.ObjectParameter" /> objects. If output parameters are used, 
            their values will not be available until the results have been read completely. This is due to the underlying behavior 
            of DbDataReader, see http://go.microsoft.com/fwlink/?LinkID=398589 for more details.
            </param>
        <summary>
            Executes the given stored procedure or function that is defined in the data source and expressed in the conceptual model, with the specified parameters, and merge option. Returns a typed
            <see cref="T:System.Data.Entity.Core.Objects.ObjectResult`1" />
            .
            </summary>
        <returns>
            An <see cref="T:System.Data.Entity.Core.Objects.ObjectResult`1" /> for the data that is returned by the stored procedure.
            </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"> function  is null or empty or function  is not found.</exception>
        <exception cref="T:System.InvalidOperationException">The entity reader does not support this  function or there is a type mismatch on the reader and the  function .</exception>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreCommand">
      <MemberSignature Language="C#" Value="public virtual int ExecuteStoreCommand (string commandText, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteStoreCommand(string commandText, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.ExecuteStoreCommand(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ExecuteStoreCommand (commandText As String, ParamArray parameters As Object()) As Integer" />
      <MemberSignature Language="F#" Value="abstract member ExecuteStoreCommand : string * obj[] -&gt; int&#xA;override this.ExecuteStoreCommand : string * obj[] -&gt; int" Usage="objectContext.ExecuteStoreCommand (commandText, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="commandText">The command specified in the server's native query language.</param>
        <param name="parameters"> The parameter values to use for the query. </param>
        <summary>
             Executes an arbitrary command directly against the data source using the existing connection.
             The command is specified using the server's native query language, such as SQL.
            
             As with any API that accepts SQL it is important to parameterize any user input to protect against a SQL injection attack. You can include parameter place holders in the SQL query string and then supply parameter values as additional arguments. Any parameter values you supply will automatically be converted to a DbParameter.
             context.ExecuteStoreCommand("UPDATE dbo.Posts SET Rating = 5 WHERE Author = @p0", userSuppliedAuthor);
             Alternatively, you can also construct a DbParameter and supply it to SqlQuery. This allows you to use named parameters in the SQL query string.
             context.ExecuteStoreCommand("UPDATE dbo.Posts SET Rating = 5 WHERE Author = @author", new SqlParameter("@author", userSuppliedAuthor));
             </summary>
        <returns>The number of rows affected.</returns>
        <remarks>
             If there isn't an existing local transaction a new transaction will be used
             to execute the command.
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreCommand">
      <MemberSignature Language="C#" Value="public virtual int ExecuteStoreCommand (System.Data.Entity.TransactionalBehavior transactionalBehavior, string commandText, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteStoreCommand(valuetype System.Data.Entity.TransactionalBehavior transactionalBehavior, string commandText, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.ExecuteStoreCommand(System.Data.Entity.TransactionalBehavior,System.String,System.Object[])" />
      <MemberSignature Language="F#" Value="abstract member ExecuteStoreCommand : System.Data.Entity.TransactionalBehavior * string * obj[] -&gt; int&#xA;override this.ExecuteStoreCommand : System.Data.Entity.TransactionalBehavior * string * obj[] -&gt; int" Usage="objectContext.ExecuteStoreCommand (transactionalBehavior, commandText, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionalBehavior" Type="System.Data.Entity.TransactionalBehavior" />
        <Parameter Name="commandText" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="transactionalBehavior"> Controls the creation of a transaction for this command. </param>
        <param name="commandText">The command specified in the server's native query language.</param>
        <param name="parameters"> The parameter values to use for the query. </param>
        <summary>
             Executes an arbitrary command directly against the data source using the existing connection.
             The command is specified using the server's native query language, such as SQL.
            
             As with any API that accepts SQL it is important to parameterize any user input to protect against a SQL injection attack. You can include parameter place holders in the SQL query string and then supply parameter values as additional arguments. Any parameter values you supply will automatically be converted to a DbParameter.
             context.ExecuteStoreCommand("UPDATE dbo.Posts SET Rating = 5 WHERE Author = @p0", userSuppliedAuthor);
             Alternatively, you can also construct a DbParameter and supply it to SqlQuery. This allows you to use named parameters in the SQL query string.
             context.ExecuteStoreCommand("UPDATE dbo.Posts SET Rating = 5 WHERE Author = @author", new SqlParameter("@author", userSuppliedAuthor));
             </summary>
        <returns>The number of rows affected.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreCommandAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;int&gt; ExecuteStoreCommandAsync (string commandText, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;int32&gt; ExecuteStoreCommandAsync(string commandText, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.ExecuteStoreCommandAsync(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteStoreCommandAsync (commandText As String, ParamArray parameters As Object()) As Task(Of Integer)" />
      <MemberSignature Language="F#" Value="member this.ExecuteStoreCommandAsync : string * obj[] -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="objectContext.ExecuteStoreCommandAsync (commandText, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="commandText">The command specified in the server's native query language.</param>
        <param name="parameters"> The parameter values to use for the query. </param>
        <summary>
             Asynchronously executes an arbitrary command directly against the data source using the existing connection.
             The command is specified using the server's native query language, such as SQL.
            
             As with any API that accepts SQL it is important to parameterize any user input to protect against a SQL injection attack. You can include parameter place holders in the SQL query string and then supply parameter values as additional arguments. Any parameter values you supply will automatically be converted to a DbParameter.
             context.ExecuteStoreCommandAsync("UPDATE dbo.Posts SET Rating = 5 WHERE Author = @p0", userSuppliedAuthor);
             Alternatively, you can also construct a DbParameter and supply it to SqlQuery. This allows you to use named parameters in the SQL query string.
             context.ExecuteStoreCommandAsync("UPDATE dbo.Posts SET Rating = 5 WHERE Author = @author", new SqlParameter("@author", userSuppliedAuthor));
             </summary>
        <returns>
              A task that represents the asynchronous operation.
             The task result contains the number of rows affected.
             </returns>
        <remarks>
             Multiple active operations on the same context instance are not supported.  Use 'await' to ensure
             that any asynchronous operations have completed before calling another method on this context.
             
             If there isn't an existing local transaction a new transaction will be used
             to execute the command.
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreCommandAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;int&gt; ExecuteStoreCommandAsync (System.Data.Entity.TransactionalBehavior transactionalBehavior, string commandText, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;int32&gt; ExecuteStoreCommandAsync(valuetype System.Data.Entity.TransactionalBehavior transactionalBehavior, string commandText, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.ExecuteStoreCommandAsync(System.Data.Entity.TransactionalBehavior,System.String,System.Object[])" />
      <MemberSignature Language="F#" Value="member this.ExecuteStoreCommandAsync : System.Data.Entity.TransactionalBehavior * string * obj[] -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="objectContext.ExecuteStoreCommandAsync (transactionalBehavior, commandText, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionalBehavior" Type="System.Data.Entity.TransactionalBehavior" />
        <Parameter Name="commandText" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="transactionalBehavior"> Controls the creation of a transaction for this command. </param>
        <param name="commandText">The command specified in the server's native query language.</param>
        <param name="parameters"> The parameter values to use for the query. </param>
        <summary>
             Asynchronously executes an arbitrary command directly against the data source using the existing connection.
             The command is specified using the server's native query language, such as SQL.
            
             As with any API that accepts SQL it is important to parameterize any user input to protect against a SQL injection attack. You can include parameter place holders in the SQL query string and then supply parameter values as additional arguments. Any parameter values you supply will automatically be converted to a DbParameter.
             context.ExecuteStoreCommandAsync("UPDATE dbo.Posts SET Rating = 5 WHERE Author = @p0", userSuppliedAuthor);
             Alternatively, you can also construct a DbParameter and supply it to SqlQuery. This allows you to use named parameters in the SQL query string.
             context.ExecuteStoreCommandAsync("UPDATE dbo.Posts SET Rating = 5 WHERE Author = @author", new SqlParameter("@author", userSuppliedAuthor));
             </summary>
        <returns>
              A task that represents the asynchronous operation.
             The task result contains the number of rows affected.
             </returns>
        <remarks>
             Multiple active operations on the same context instance are not supported.  Use 'await' to ensure
             that any asynchronous operations have completed before calling another method on this context.
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreCommandAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ExecuteStoreCommandAsync (string commandText, System.Threading.CancellationToken cancellationToken, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ExecuteStoreCommandAsync(string commandText, valuetype System.Threading.CancellationToken cancellationToken, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.ExecuteStoreCommandAsync(System.String,System.Threading.CancellationToken,System.Object[])" />
      <MemberSignature Language="F#" Value="abstract member ExecuteStoreCommandAsync : string * System.Threading.CancellationToken * obj[] -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ExecuteStoreCommandAsync : string * System.Threading.CancellationToken * obj[] -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="objectContext.ExecuteStoreCommandAsync (commandText, cancellationToken, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="commandText">The command specified in the server's native query language.</param>
        <param name="cancellationToken">
             A <see cref="T:System.Threading.CancellationToken" /> to observe while waiting for the task to complete.
             </param>
        <param name="parameters"> The parameter values to use for the query. </param>
        <summary>
             Asynchronously executes an arbitrary command directly against the data source using the existing connection.
             The command is specified using the server's native query language, such as SQL.
            
             As with any API that accepts SQL it is important to parameterize any user input to protect against a SQL injection attack. You can include parameter place holders in the SQL query string and then supply parameter values as additional arguments. Any parameter values you supply will automatically be converted to a DbParameter.
             context.ExecuteStoreCommandAsync("UPDATE dbo.Posts SET Rating = 5 WHERE Author = @p0", userSuppliedAuthor);
             Alternatively, you can also construct a DbParameter and supply it to SqlQuery. This allows you to use named parameters in the SQL query string.
             context.ExecuteStoreCommandAsync("UPDATE dbo.Posts SET Rating = 5 WHERE Author = @author", new SqlParameter("@author", userSuppliedAuthor));
             </summary>
        <returns>
              A task that represents the asynchronous operation.
             The task result contains the number of rows affected.
             </returns>
        <remarks>
             Multiple active operations on the same context instance are not supported.  Use 'await' to ensure
             that any asynchronous operations have completed before calling another method on this context.
             
             If there isn't an existing local transaction a new transaction will be used
             to execute the command.
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreCommandAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ExecuteStoreCommandAsync (System.Data.Entity.TransactionalBehavior transactionalBehavior, string commandText, System.Threading.CancellationToken cancellationToken, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ExecuteStoreCommandAsync(valuetype System.Data.Entity.TransactionalBehavior transactionalBehavior, string commandText, valuetype System.Threading.CancellationToken cancellationToken, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.ExecuteStoreCommandAsync(System.Data.Entity.TransactionalBehavior,System.String,System.Threading.CancellationToken,System.Object[])" />
      <MemberSignature Language="F#" Value="abstract member ExecuteStoreCommandAsync : System.Data.Entity.TransactionalBehavior * string * System.Threading.CancellationToken * obj[] -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ExecuteStoreCommandAsync : System.Data.Entity.TransactionalBehavior * string * System.Threading.CancellationToken * obj[] -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="objectContext.ExecuteStoreCommandAsync (transactionalBehavior, commandText, cancellationToken, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionalBehavior" Type="System.Data.Entity.TransactionalBehavior" />
        <Parameter Name="commandText" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="transactionalBehavior"> Controls the creation of a transaction for this command. </param>
        <param name="commandText">The command specified in the server's native query language.</param>
        <param name="cancellationToken">
             A <see cref="T:System.Threading.CancellationToken" /> to observe while waiting for the task to complete.
             </param>
        <param name="parameters"> The parameter values to use for the query. </param>
        <summary>
             Asynchronously executes an arbitrary command directly against the data source using the existing connection.
             The command is specified using the server's native query language, such as SQL.
            
             As with any API that accepts SQL it is important to parameterize any user input to protect against a SQL injection attack. You can include parameter place holders in the SQL query string and then supply parameter values as additional arguments. Any parameter values you supply will automatically be converted to a DbParameter.
             context.ExecuteStoreCommandAsync("UPDATE dbo.Posts SET Rating = 5 WHERE Author = @p0", userSuppliedAuthor);
             Alternatively, you can also construct a DbParameter and supply it to SqlQuery. This allows you to use named parameters in the SQL query string.
             context.ExecuteStoreCommandAsync("UPDATE dbo.Posts SET Rating = 5 WHERE Author = @author", new SqlParameter("@author", userSuppliedAuthor));
             </summary>
        <returns>
              A task that represents the asynchronous operation.
             The task result contains the number of rows affected.
             </returns>
        <remarks>
             Multiple active operations on the same context instance are not supported.  Use 'await' to ensure
             that any asynchronous operations have completed before calling another method on this context.
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreQuery&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public virtual System.Data.Entity.Core.Objects.ObjectResult&lt;TElement&gt; ExecuteStoreQuery&lt;TElement&gt; (string commandText, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.Entity.Core.Objects.ObjectResult`1&lt;!!TElement&gt; ExecuteStoreQuery&lt;TElement&gt;(string commandText, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.ExecuteStoreQuery``1(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ExecuteStoreQuery(Of TElement) (commandText As String, ParamArray parameters As Object()) As ObjectResult(Of TElement)" />
      <MemberSignature Language="F#" Value="abstract member ExecuteStoreQuery : string * obj[] -&gt; System.Data.Entity.Core.Objects.ObjectResult&lt;'Element&gt;&#xA;override this.ExecuteStoreQuery : string * obj[] -&gt; System.Data.Entity.Core.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.ExecuteStoreQuery (commandText, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Entity.Core.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement"> The element type of the result sequence. </typeparam>
        <param name="commandText"> The query specified in the server's native query language. </param>
        <param name="parameters"> 
             The parameter values to use for the query. If output parameters are used, their values will not be 
             available until the results have been read completely. This is due to the underlying behavior 
             of DbDataReader, see http://go.microsoft.com/fwlink/?LinkID=398589 for more details.
             </param>
        <summary>
             Executes a query directly against the data source and returns a sequence of typed results. 
             The query is specified using the server's native query language, such as SQL.
             Results are not tracked by the context, use the overload that specifies an entity set name to track results.
            
             As with any API that accepts SQL it is important to parameterize any user input to protect against a SQL injection attack. You can include parameter place holders in the SQL query string and then supply parameter values as additional arguments. Any parameter values you supply will automatically be converted to a DbParameter.
             context.ExecuteStoreQuery&lt;Post&gt;("SELECT * FROM dbo.Posts WHERE Author = @p0", userSuppliedAuthor);
             Alternatively, you can also construct a DbParameter and supply it to SqlQuery. This allows you to use named parameters in the SQL query string.
             context.ExecuteStoreQuery&lt;Post&gt;("SELECT * FROM dbo.Posts WHERE Author = @author", new SqlParameter("@author", userSuppliedAuthor));
             </summary>
        <returns>
             An enumeration of objects of type <typeparamref name="TElement" /> .
             </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreQuery&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public virtual System.Data.Entity.Core.Objects.ObjectResult&lt;TElement&gt; ExecuteStoreQuery&lt;TElement&gt; (string commandText, System.Data.Entity.Core.Objects.ExecutionOptions executionOptions, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.Entity.Core.Objects.ObjectResult`1&lt;!!TElement&gt; ExecuteStoreQuery&lt;TElement&gt;(string commandText, class System.Data.Entity.Core.Objects.ExecutionOptions executionOptions, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.ExecuteStoreQuery``1(System.String,System.Data.Entity.Core.Objects.ExecutionOptions,System.Object[])" />
      <MemberSignature Language="F#" Value="abstract member ExecuteStoreQuery : string * System.Data.Entity.Core.Objects.ExecutionOptions * obj[] -&gt; System.Data.Entity.Core.Objects.ObjectResult&lt;'Element&gt;&#xA;override this.ExecuteStoreQuery : string * System.Data.Entity.Core.Objects.ExecutionOptions * obj[] -&gt; System.Data.Entity.Core.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.ExecuteStoreQuery (commandText, executionOptions, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Entity.Core.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" />
        <Parameter Name="executionOptions" Type="System.Data.Entity.Core.Objects.ExecutionOptions" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement"> The element type of the result sequence. </typeparam>
        <param name="commandText"> The query specified in the server's native query language. </param>
        <param name="executionOptions"> The options for executing this query. </param>
        <param name="parameters"> 
             The parameter values to use for the query. If output parameters are used, their values will not be 
             available until the results have been read completely. This is due to the underlying behavior of 
             DbDataReader, see http://go.microsoft.com/fwlink/?LinkID=398589 for more details.
             </param>
        <summary>
             Executes a query directly against the data source and returns a sequence of typed results. 
             The query is specified using the server's native query language, such as SQL.
             Results are not tracked by the context, use the overload that specifies an entity set name to track results.
            
             As with any API that accepts SQL it is important to parameterize any user input to protect against a SQL injection attack. You can include parameter place holders in the SQL query string and then supply parameter values as additional arguments. Any parameter values you supply will automatically be converted to a DbParameter.
             context.ExecuteStoreQuery&lt;Post&gt;("SELECT * FROM dbo.Posts WHERE Author = @p0", userSuppliedAuthor);
             Alternatively, you can also construct a DbParameter and supply it to SqlQuery. This allows you to use named parameters in the SQL query string.
             context.ExecuteStoreQuery&lt;Post&gt;("SELECT * FROM dbo.Posts WHERE Author = @author", new SqlParameter("@author", userSuppliedAuthor));
             </summary>
        <returns>
             An enumeration of objects of type <typeparamref name="TElement" /> .
             </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreQuery&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public virtual System.Data.Entity.Core.Objects.ObjectResult&lt;TElement&gt; ExecuteStoreQuery&lt;TElement&gt; (string commandText, string entitySetName, System.Data.Entity.Core.Objects.ExecutionOptions executionOptions, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.Entity.Core.Objects.ObjectResult`1&lt;!!TElement&gt; ExecuteStoreQuery&lt;TElement&gt;(string commandText, string entitySetName, class System.Data.Entity.Core.Objects.ExecutionOptions executionOptions, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.ExecuteStoreQuery``1(System.String,System.String,System.Data.Entity.Core.Objects.ExecutionOptions,System.Object[])" />
      <MemberSignature Language="F#" Value="abstract member ExecuteStoreQuery : string * string * System.Data.Entity.Core.Objects.ExecutionOptions * obj[] -&gt; System.Data.Entity.Core.Objects.ObjectResult&lt;'Element&gt;&#xA;override this.ExecuteStoreQuery : string * string * System.Data.Entity.Core.Objects.ExecutionOptions * obj[] -&gt; System.Data.Entity.Core.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.ExecuteStoreQuery (commandText, entitySetName, executionOptions, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Entity.Core.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" />
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="executionOptions" Type="System.Data.Entity.Core.Objects.ExecutionOptions" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement"> The element type of the result sequence. </typeparam>
        <param name="commandText"> The query specified in the server's native query language. </param>
        <param name="entitySetName">The entity set of the  TResult  type. If an entity set name is not provided, the results are not going to be tracked.</param>
        <param name="executionOptions"> The options for executing this query. </param>
        <param name="parameters"> 
             The parameter values to use for the query. If output parameters are used, their values will not be 
             available until the results have been read completely. This is due to the underlying behavior 
             of DbDataReader, see http://go.microsoft.com/fwlink/?LinkID=398589 for more details.
             </param>
        <summary>
             Executes a query directly against the data source and returns a sequence of typed results. 
             The query is specified using the server's native query language, such as SQL.
             If an entity set name is specified, results are tracked by the context.
            
             As with any API that accepts SQL it is important to parameterize any user input to protect against a SQL injection attack. You can include parameter place holders in the SQL query string and then supply parameter values as additional arguments. Any parameter values you supply will automatically be converted to a DbParameter.
             context.ExecuteStoreQuery&lt;Post&gt;("SELECT * FROM dbo.Posts WHERE Author = @p0", userSuppliedAuthor);
             Alternatively, you can also construct a DbParameter and supply it to SqlQuery. This allows you to use named parameters in the SQL query string.
             context.ExecuteStoreQuery&lt;Post&gt;("SELECT * FROM dbo.Posts WHERE Author = @author", new SqlParameter("@author", userSuppliedAuthor));
             </summary>
        <returns>
             An enumeration of objects of type <typeparamref name="TElement" /> .
             </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreQuery&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public virtual System.Data.Entity.Core.Objects.ObjectResult&lt;TElement&gt; ExecuteStoreQuery&lt;TElement&gt; (string commandText, string entitySetName, System.Data.Entity.Core.Objects.MergeOption mergeOption, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.Entity.Core.Objects.ObjectResult`1&lt;!!TElement&gt; ExecuteStoreQuery&lt;TElement&gt;(string commandText, string entitySetName, valuetype System.Data.Entity.Core.Objects.MergeOption mergeOption, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.ExecuteStoreQuery``1(System.String,System.String,System.Data.Entity.Core.Objects.MergeOption,System.Object[])" />
      <MemberSignature Language="F#" Value="abstract member ExecuteStoreQuery : string * string * System.Data.Entity.Core.Objects.MergeOption * obj[] -&gt; System.Data.Entity.Core.Objects.ObjectResult&lt;'Element&gt;&#xA;override this.ExecuteStoreQuery : string * string * System.Data.Entity.Core.Objects.MergeOption * obj[] -&gt; System.Data.Entity.Core.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.ExecuteStoreQuery (commandText, entitySetName, mergeOption, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Entity.Core.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" />
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="mergeOption" Type="System.Data.Entity.Core.Objects.MergeOption" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement"> The element type of the result sequence. </typeparam>
        <param name="commandText"> The query specified in the server's native query language. </param>
        <param name="entitySetName">The entity set of the  TResult  type. If an entity set name is not provided, the results are not going to be tracked.</param>
        <param name="mergeOption">
             The <see cref="T:System.Data.Entity.Core.Objects.MergeOption" /> to use when executing the query. The default is
             <see cref="F:System.Data.Entity.Core.Objects.MergeOption.AppendOnly" />.
             </param>
        <param name="parameters"> 
             The parameter values to use for the query. If output parameters are used, their values will not be 
             available until the results have been read completely. This is due to the underlying behavior 
             of DbDataReader, see http://go.microsoft.com/fwlink/?LinkID=398589 for more details.
             </param>
        <summary>
             Executes a query directly against the data source and returns a sequence of typed results. 
             The query is specified using the server's native query language, such as SQL.
             If an entity set name is specified, results are tracked by the context.
            
             As with any API that accepts SQL it is important to parameterize any user input to protect against a SQL injection attack. You can include parameter place holders in the SQL query string and then supply parameter values as additional arguments. Any parameter values you supply will automatically be converted to a DbParameter.
             context.ExecuteStoreQuery&lt;Post&gt;("SELECT * FROM dbo.Posts WHERE Author = @p0", userSuppliedAuthor);
             Alternatively, you can also construct a DbParameter and supply it to SqlQuery. This allows you to use named parameters in the SQL query string.
             context.ExecuteStoreQuery&lt;Post&gt;("SELECT * FROM dbo.Posts WHERE Author = @author", new SqlParameter("@author", userSuppliedAuthor));
             </summary>
        <returns>
             An enumeration of objects of type <typeparamref name="TElement" /> .
             </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreQueryAsync&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Data.Entity.Core.Objects.ObjectResult&lt;TElement&gt;&gt; ExecuteStoreQueryAsync&lt;TElement&gt; (string commandText, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Data.Entity.Core.Objects.ObjectResult`1&lt;!!TElement&gt;&gt; ExecuteStoreQueryAsync&lt;TElement&gt;(string commandText, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.ExecuteStoreQueryAsync``1(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteStoreQueryAsync(Of TElement) (commandText As String, ParamArray parameters As Object()) As Task(Of ObjectResult(Of TElement))" />
      <MemberSignature Language="F#" Value="member this.ExecuteStoreQueryAsync : string * obj[] -&gt; System.Threading.Tasks.Task&lt;System.Data.Entity.Core.Objects.ObjectResult&lt;'Element&gt;&gt;" Usage="objectContext.ExecuteStoreQueryAsync (commandText, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Data.Entity.Core.Objects.ObjectResult&lt;TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement"> The element type of the result sequence. </typeparam>
        <param name="commandText"> The query specified in the server's native query language. </param>
        <param name="parameters"> 
             The parameter values to use for the query. If output parameters are used, their values will not be 
             available until the results have been read completely. This is due to the underlying behavior 
             of DbDataReader, see http://go.microsoft.com/fwlink/?LinkID=398589 for more details.
             </param>
        <summary>
             Asynchronously executes a query directly against the data source and returns a sequence of typed results. 
             The query is specified using the server's native query language, such as SQL.
             Results are not tracked by the context, use the overload that specifies an entity set name to track results.
            
             As with any API that accepts SQL it is important to parameterize any user input to protect against a SQL injection attack. You can include parameter place holders in the SQL query string and then supply parameter values as additional arguments. Any parameter values you supply will automatically be converted to a DbParameter.
             context.ExecuteStoreQueryAsync&lt;Post&gt;("SELECT * FROM dbo.Posts WHERE Author = @p0", userSuppliedAuthor);
             Alternatively, you can also construct a DbParameter and supply it to SqlQuery. This allows you to use named parameters in the SQL query string.
             context.ExecuteStoreQueryAsync&lt;Post&gt;("SELECT * FROM dbo.Posts WHERE Author = @author", new SqlParameter("@author", userSuppliedAuthor));
             </summary>
        <returns>
             A task that represents the asynchronous operation.
             The task result contains an enumeration of objects of type <typeparamref name="TElement" /> .
             </returns>
        <remarks>
             Multiple active operations on the same context instance are not supported.  Use 'await' to ensure
             that any asynchronous operations have completed before calling another method on this context.
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreQueryAsync&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;System.Data.Entity.Core.Objects.ObjectResult&lt;TElement&gt;&gt; ExecuteStoreQueryAsync&lt;TElement&gt; (string commandText, System.Data.Entity.Core.Objects.ExecutionOptions executionOptions, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class System.Data.Entity.Core.Objects.ObjectResult`1&lt;!!TElement&gt;&gt; ExecuteStoreQueryAsync&lt;TElement&gt;(string commandText, class System.Data.Entity.Core.Objects.ExecutionOptions executionOptions, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.ExecuteStoreQueryAsync``1(System.String,System.Data.Entity.Core.Objects.ExecutionOptions,System.Object[])" />
      <MemberSignature Language="F#" Value="abstract member ExecuteStoreQueryAsync : string * System.Data.Entity.Core.Objects.ExecutionOptions * obj[] -&gt; System.Threading.Tasks.Task&lt;System.Data.Entity.Core.Objects.ObjectResult&lt;'Element&gt;&gt;&#xA;override this.ExecuteStoreQueryAsync : string * System.Data.Entity.Core.Objects.ExecutionOptions * obj[] -&gt; System.Threading.Tasks.Task&lt;System.Data.Entity.Core.Objects.ObjectResult&lt;'Element&gt;&gt;" Usage="objectContext.ExecuteStoreQueryAsync (commandText, executionOptions, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Data.Entity.Core.Objects.ObjectResult&lt;TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" />
        <Parameter Name="executionOptions" Type="System.Data.Entity.Core.Objects.ExecutionOptions" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement"> The element type of the result sequence. </typeparam>
        <param name="commandText"> The query specified in the server's native query language. </param>
        <param name="executionOptions"> The options for executing this query. </param>
        <param name="parameters"> 
             The parameter values to use for the query. If output parameters are used, their values will not be 
             available until the results have been read completely. This is due to the underlying behavior 
             of DbDataReader, see http://go.microsoft.com/fwlink/?LinkID=398589 for more details.
             </param>
        <summary>
             Asynchronously executes a query directly against the data source and returns a sequence of typed results. 
             The query is specified using the server's native query language, such as SQL.
             Results are not tracked by the context, use the overload that specifies an entity set name to track results.
            
             As with any API that accepts SQL it is important to parameterize any user input to protect against a SQL injection attack. You can include parameter place holders in the SQL query string and then supply parameter values as additional arguments. Any parameter values you supply will automatically be converted to a DbParameter.
             context.ExecuteStoreQueryAsync&lt;Post&gt;("SELECT * FROM dbo.Posts WHERE Author = @p0", userSuppliedAuthor);
             Alternatively, you can also construct a DbParameter and supply it to SqlQuery. This allows you to use named parameters in the SQL query string.
             context.ExecuteStoreQueryAsync&lt;Post&gt;("SELECT * FROM dbo.Posts WHERE Author = @author", new SqlParameter("@author", userSuppliedAuthor));
             </summary>
        <returns>
             A task that represents the asynchronous operation.
             The task result contains an enumeration of objects of type <typeparamref name="TElement" /> .
             </returns>
        <remarks>
             Multiple active operations on the same context instance are not supported.  Use 'await' to ensure
             that any asynchronous operations have completed before calling another method on this context.
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreQueryAsync&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;System.Data.Entity.Core.Objects.ObjectResult&lt;TElement&gt;&gt; ExecuteStoreQueryAsync&lt;TElement&gt; (string commandText, System.Threading.CancellationToken cancellationToken, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class System.Data.Entity.Core.Objects.ObjectResult`1&lt;!!TElement&gt;&gt; ExecuteStoreQueryAsync&lt;TElement&gt;(string commandText, valuetype System.Threading.CancellationToken cancellationToken, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.ExecuteStoreQueryAsync``1(System.String,System.Threading.CancellationToken,System.Object[])" />
      <MemberSignature Language="F#" Value="abstract member ExecuteStoreQueryAsync : string * System.Threading.CancellationToken * obj[] -&gt; System.Threading.Tasks.Task&lt;System.Data.Entity.Core.Objects.ObjectResult&lt;'Element&gt;&gt;&#xA;override this.ExecuteStoreQueryAsync : string * System.Threading.CancellationToken * obj[] -&gt; System.Threading.Tasks.Task&lt;System.Data.Entity.Core.Objects.ObjectResult&lt;'Element&gt;&gt;" Usage="objectContext.ExecuteStoreQueryAsync (commandText, cancellationToken, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Data.Entity.Core.Objects.ObjectResult&lt;TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement"> The element type of the result sequence. </typeparam>
        <param name="commandText"> The query specified in the server's native query language. </param>
        <param name="cancellationToken">
             A <see cref="T:System.Threading.CancellationToken" /> to observe while waiting for the task to complete.
             </param>
        <param name="parameters"> 
             The parameter values to use for the query. If output parameters are used, their values will not be 
             available until the results have been read completely. This is due to the underlying behavior 
             of DbDataReader, see http://go.microsoft.com/fwlink/?LinkID=398589 for more details.
             </param>
        <summary>
             Asynchronously executes a query directly against the data source and returns a sequence of typed results. 
             The query is specified using the server's native query language, such as SQL.
             Results are not tracked by the context, use the overload that specifies an entity set name to track results.
            
             As with any API that accepts SQL it is important to parameterize any user input to protect against a SQL injection attack. You can include parameter place holders in the SQL query string and then supply parameter values as additional arguments. Any parameter values you supply will automatically be converted to a DbParameter.
             context.ExecuteStoreQueryAsync&lt;Post&gt;("SELECT * FROM dbo.Posts WHERE Author = @p0", userSuppliedAuthor);
             Alternatively, you can also construct a DbParameter and supply it to SqlQuery. This allows you to use named parameters in the SQL query string.
             context.ExecuteStoreQueryAsync&lt;Post&gt;("SELECT * FROM dbo.Posts WHERE Author = @author", new SqlParameter("@author", userSuppliedAuthor));
             </summary>
        <returns>
             A task that represents the asynchronous operation.
             The task result contains an enumeration of objects of type <typeparamref name="TElement" /> .
             </returns>
        <remarks>
             Multiple active operations on the same context instance are not supported.  Use 'await' to ensure
             that any asynchronous operations have completed before calling another method on this context.
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreQueryAsync&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;System.Data.Entity.Core.Objects.ObjectResult&lt;TElement&gt;&gt; ExecuteStoreQueryAsync&lt;TElement&gt; (string commandText, System.Data.Entity.Core.Objects.ExecutionOptions executionOptions, System.Threading.CancellationToken cancellationToken, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class System.Data.Entity.Core.Objects.ObjectResult`1&lt;!!TElement&gt;&gt; ExecuteStoreQueryAsync&lt;TElement&gt;(string commandText, class System.Data.Entity.Core.Objects.ExecutionOptions executionOptions, valuetype System.Threading.CancellationToken cancellationToken, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.ExecuteStoreQueryAsync``1(System.String,System.Data.Entity.Core.Objects.ExecutionOptions,System.Threading.CancellationToken,System.Object[])" />
      <MemberSignature Language="F#" Value="abstract member ExecuteStoreQueryAsync : string * System.Data.Entity.Core.Objects.ExecutionOptions * System.Threading.CancellationToken * obj[] -&gt; System.Threading.Tasks.Task&lt;System.Data.Entity.Core.Objects.ObjectResult&lt;'Element&gt;&gt;&#xA;override this.ExecuteStoreQueryAsync : string * System.Data.Entity.Core.Objects.ExecutionOptions * System.Threading.CancellationToken * obj[] -&gt; System.Threading.Tasks.Task&lt;System.Data.Entity.Core.Objects.ObjectResult&lt;'Element&gt;&gt;" Usage="objectContext.ExecuteStoreQueryAsync (commandText, executionOptions, cancellationToken, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Data.Entity.Core.Objects.ObjectResult&lt;TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" />
        <Parameter Name="executionOptions" Type="System.Data.Entity.Core.Objects.ExecutionOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement"> The element type of the result sequence. </typeparam>
        <param name="commandText"> The query specified in the server's native query language. </param>
        <param name="executionOptions"> The options for executing this query. </param>
        <param name="cancellationToken">
             A <see cref="T:System.Threading.CancellationToken" /> to observe while waiting for the task to complete.
             </param>
        <param name="parameters"> 
             The parameter values to use for the query. If output parameters are used, their values will not be 
             available until the results have been read completely. This is due to the underlying behavior 
             of DbDataReader, see http://go.microsoft.com/fwlink/?LinkID=398589 for more details.
             </param>
        <summary>
             Asynchronously executes a query directly against the data source and returns a sequence of typed results. 
             The query is specified using the server's native query language, such as SQL.
             Results are not tracked by the context, use the overload that specifies an entity set name to track results.
            
             As with any API that accepts SQL it is important to parameterize any user input to protect against a SQL injection attack. You can include parameter place holders in the SQL query string and then supply parameter values as additional arguments. Any parameter values you supply will automatically be converted to a DbParameter.
             context.ExecuteStoreQueryAsync&lt;Post&gt;("SELECT * FROM dbo.Posts WHERE Author = @p0", userSuppliedAuthor);
             Alternatively, you can also construct a DbParameter and supply it to SqlQuery. This allows you to use named parameters in the SQL query string.
             context.ExecuteStoreQueryAsync&lt;Post&gt;("SELECT * FROM dbo.Posts WHERE Author = @author", new SqlParameter("@author", userSuppliedAuthor));
             </summary>
        <returns>
             A task that represents the asynchronous operation.
             The task result contains an enumeration of objects of type <typeparamref name="TElement" /> .
             </returns>
        <remarks>
             Multiple active operations on the same context instance are not supported.  Use 'await' to ensure
             that any asynchronous operations have completed before calling another method on this context.
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreQueryAsync&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Data.Entity.Core.Objects.ObjectResult&lt;TElement&gt;&gt; ExecuteStoreQueryAsync&lt;TElement&gt; (string commandText, string entitySetName, System.Data.Entity.Core.Objects.ExecutionOptions executionOptions, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Data.Entity.Core.Objects.ObjectResult`1&lt;!!TElement&gt;&gt; ExecuteStoreQueryAsync&lt;TElement&gt;(string commandText, string entitySetName, class System.Data.Entity.Core.Objects.ExecutionOptions executionOptions, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.ExecuteStoreQueryAsync``1(System.String,System.String,System.Data.Entity.Core.Objects.ExecutionOptions,System.Object[])" />
      <MemberSignature Language="F#" Value="member this.ExecuteStoreQueryAsync : string * string * System.Data.Entity.Core.Objects.ExecutionOptions * obj[] -&gt; System.Threading.Tasks.Task&lt;System.Data.Entity.Core.Objects.ObjectResult&lt;'Element&gt;&gt;" Usage="objectContext.ExecuteStoreQueryAsync (commandText, entitySetName, executionOptions, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Data.Entity.Core.Objects.ObjectResult&lt;TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" />
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="executionOptions" Type="System.Data.Entity.Core.Objects.ExecutionOptions" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement"> The element type of the result sequence. </typeparam>
        <param name="commandText"> The query specified in the server's native query language. </param>
        <param name="entitySetName">The entity set of the  TResult  type. If an entity set name is not provided, the results are not going to be tracked.</param>
        <param name="executionOptions"> The options for executing this query. </param>
        <param name="parameters"> 
             The parameter values to use for the query. If output parameters are used, their values will not be 
             available until the results have been read completely. This is due to the underlying behavior 
             of DbDataReader, see http://go.microsoft.com/fwlink/?LinkID=398589 for more details.
             </param>
        <summary>
             Asynchronously executes a query directly against the data source and returns a sequence of typed results. 
             The query is specified using the server's native query language, such as SQL.
             If an entity set name is specified, results are tracked by the context.
            
             As with any API that accepts SQL it is important to parameterize any user input to protect against a SQL injection attack. You can include parameter place holders in the SQL query string and then supply parameter values as additional arguments. Any parameter values you supply will automatically be converted to a DbParameter.
             context.ExecuteStoreQueryAsync&lt;Post&gt;("SELECT * FROM dbo.Posts WHERE Author = @p0", userSuppliedAuthor);
             Alternatively, you can also construct a DbParameter and supply it to SqlQuery. This allows you to use named parameters in the SQL query string.
             context.ExecuteStoreQueryAsync&lt;Post&gt;("SELECT * FROM dbo.Posts WHERE Author = @author", new SqlParameter("@author", userSuppliedAuthor));
             </summary>
        <returns>
             A task that represents the asynchronous operation.
             The task result contains an enumeration of objects of type <typeparamref name="TElement" /> .
             </returns>
        <remarks>
             Multiple active operations on the same context instance are not supported.  Use 'await' to ensure
             that any asynchronous operations have completed before calling another method on this context.
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreQueryAsync&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;System.Data.Entity.Core.Objects.ObjectResult&lt;TElement&gt;&gt; ExecuteStoreQueryAsync&lt;TElement&gt; (string commandText, string entitySetName, System.Data.Entity.Core.Objects.ExecutionOptions executionOptions, System.Threading.CancellationToken cancellationToken, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class System.Data.Entity.Core.Objects.ObjectResult`1&lt;!!TElement&gt;&gt; ExecuteStoreQueryAsync&lt;TElement&gt;(string commandText, string entitySetName, class System.Data.Entity.Core.Objects.ExecutionOptions executionOptions, valuetype System.Threading.CancellationToken cancellationToken, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.ExecuteStoreQueryAsync``1(System.String,System.String,System.Data.Entity.Core.Objects.ExecutionOptions,System.Threading.CancellationToken,System.Object[])" />
      <MemberSignature Language="F#" Value="abstract member ExecuteStoreQueryAsync : string * string * System.Data.Entity.Core.Objects.ExecutionOptions * System.Threading.CancellationToken * obj[] -&gt; System.Threading.Tasks.Task&lt;System.Data.Entity.Core.Objects.ObjectResult&lt;'Element&gt;&gt;&#xA;override this.ExecuteStoreQueryAsync : string * string * System.Data.Entity.Core.Objects.ExecutionOptions * System.Threading.CancellationToken * obj[] -&gt; System.Threading.Tasks.Task&lt;System.Data.Entity.Core.Objects.ObjectResult&lt;'Element&gt;&gt;" Usage="objectContext.ExecuteStoreQueryAsync (commandText, entitySetName, executionOptions, cancellationToken, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Data.Entity.Core.Objects.ObjectResult&lt;TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" />
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="executionOptions" Type="System.Data.Entity.Core.Objects.ExecutionOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement"> The element type of the result sequence. </typeparam>
        <param name="commandText"> The query specified in the server's native query language. </param>
        <param name="entitySetName">The entity set of the  TResult  type. If an entity set name is not provided, the results are not going to be tracked.</param>
        <param name="executionOptions"> The options for executing this query. </param>
        <param name="cancellationToken">
             A <see cref="T:System.Threading.CancellationToken" /> to observe while waiting for the task to complete.
             </param>
        <param name="parameters"> 
             The parameter values to use for the query. If output parameters are used, their values will not be 
             available until the results have been read completely. This is due to the underlying behavior 
             of DbDataReader, see http://go.microsoft.com/fwlink/?LinkID=398589 for more details.
             </param>
        <summary>
             Asynchronously executes a query directly against the data source and returns a sequence of typed results. 
             The query is specified using the server's native query language, such as SQL.
             If an entity set name is specified, results are tracked by the context.
            
             As with any API that accepts SQL it is important to parameterize any user input to protect against a SQL injection attack. You can include parameter place holders in the SQL query string and then supply parameter values as additional arguments. Any parameter values you supply will automatically be converted to a DbParameter.
             context.ExecuteStoreQueryAsync&lt;Post&gt;("SELECT * FROM dbo.Posts WHERE Author = @p0", userSuppliedAuthor);
             Alternatively, you can also construct a DbParameter and supply it to SqlQuery. This allows you to use named parameters in the SQL query string.
             context.ExecuteStoreQueryAsync&lt;Post&gt;("SELECT * FROM dbo.Posts WHERE Author = @author", new SqlParameter("@author", userSuppliedAuthor));
             </summary>
        <returns>
             A task that represents the asynchronous operation.
             The task result contains an enumeration of objects of type <typeparamref name="TElement" /> .
             </returns>
        <remarks>
             Multiple active operations on the same context instance are not supported.  Use 'await' to ensure
             that any asynchronous operations have completed before calling another method on this context.
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~ObjectContext ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="objectContext.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Finalizes an instance of the <see cref="T:System.Data.Entity.Core.Objects.ObjectContext" /> class.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetKnownProxyTypes">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;Type&gt; GetKnownProxyTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; GetKnownProxyTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.GetKnownProxyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetKnownProxyTypes () As IEnumerable(Of Type)" />
      <MemberSignature Language="F#" Value="static member GetKnownProxyTypes : unit -&gt; seq&lt;Type&gt;" Usage="System.Data.Entity.Core.Objects.ObjectContext.GetKnownProxyTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns all the existing proxy types.</summary>
        <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of all the existing proxy types.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectByKey">
      <MemberSignature Language="C#" Value="public virtual object GetObjectByKey (System.Data.Entity.Core.EntityKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetObjectByKey(class System.Data.Entity.Core.EntityKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.GetObjectByKey(System.Data.Entity.Core.EntityKey)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetObjectByKey (key As EntityKey) As Object" />
      <MemberSignature Language="F#" Value="abstract member GetObjectByKey : System.Data.Entity.Core.EntityKey -&gt; obj&#xA;override this.GetObjectByKey : System.Data.Entity.Core.EntityKey -&gt; obj" Usage="objectContext.GetObjectByKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.Entity.Core.EntityKey" />
      </Parameters>
      <Docs>
        <param name="key">The key of the object to be found.</param>
        <summary>Returns an object that has the specified entity key.</summary>
        <returns>
            An <see cref="T:System.Object" /> that is an instance of an entity type.
            </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">The  key  parameter is null.</exception>
        <exception cref="T:System.Data.Entity.Core.ObjectNotFoundException">
            The object is not found in either the <see cref="T:System.Data.Entity.Core.Objects.ObjectStateManager" /> or the data source.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="GetObjectType">
      <MemberSignature Language="C#" Value="public static Type GetObjectType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetObjectType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.GetObjectType(System.Type)" />
      <MemberSignature Language="F#" Value="static member GetObjectType : Type -&gt; Type" Usage="System.Data.Entity.Core.Objects.ObjectContext.GetObjectType type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
            The <see cref="T:System.Type" /> of the proxy object.
            </param>
        <summary>Returns the entity type of the POCO entity associated with a proxy object of a specified type.</summary>
        <returns>
            The <see cref="T:System.Type" /> of the associated POCO entity.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InterceptionContext">
      <MemberSignature Language="C#" Value="public System.Data.Entity.Infrastructure.Interception.DbInterceptionContext InterceptionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Entity.Infrastructure.Interception.DbInterceptionContext InterceptionContext" />
      <MemberSignature Language="DocId" Value="P:System.Data.Entity.Core.Objects.ObjectContext.InterceptionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InterceptionContext As DbInterceptionContext" />
      <MemberSignature Language="F#" Value="member this.InterceptionContext : System.Data.Entity.Infrastructure.Interception.DbInterceptionContext" Usage="System.Data.Entity.Core.Objects.ObjectContext.InterceptionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Entity.Infrastructure.Interception.DbInterceptionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Returns the <see cref="T:System.Data.Entity.Infrastructure.Interception.DbInterceptionContext" /> being used for this context.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadProperty">
      <MemberSignature Language="C#" Value="public virtual void LoadProperty (object entity, string navigationProperty);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LoadProperty(object entity, string navigationProperty) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.LoadProperty(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub LoadProperty (entity As Object, navigationProperty As String)" />
      <MemberSignature Language="F#" Value="abstract member LoadProperty : obj * string -&gt; unit&#xA;override this.LoadProperty : obj * string -&gt; unit" Usage="objectContext.LoadProperty (entity, navigationProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
        <Parameter Name="navigationProperty" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="entity">The entity for which related objects are to be loaded.</param>
        <param name="navigationProperty">The name of the navigation property that returns the related objects to be loaded.</param>
        <summary>Explicitly loads an object related to the supplied object by the specified navigation property and using the default merge option. </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">
            The  entity  is in a <see cref="F:System.Data.Entity.EntityState.Detached" />,
            <see cref="F:System.Data.Entity.EntityState.Added," />
            or <see cref="F:System.Data.Entity.EntityState.Deleted" /> state or the  entity  is attached to another instance of
            <see cref="T:System.Data.Entity.Core.Objects.ObjectContext" />
            .
            </exception>
      </Docs>
    </Member>
    <Member MemberName="LoadProperty">
      <MemberSignature Language="C#" Value="public virtual void LoadProperty (object entity, string navigationProperty, System.Data.Entity.Core.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LoadProperty(object entity, string navigationProperty, valuetype System.Data.Entity.Core.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.LoadProperty(System.Object,System.String,System.Data.Entity.Core.Objects.MergeOption)" />
      <MemberSignature Language="F#" Value="abstract member LoadProperty : obj * string * System.Data.Entity.Core.Objects.MergeOption -&gt; unit&#xA;override this.LoadProperty : obj * string * System.Data.Entity.Core.Objects.MergeOption -&gt; unit" Usage="objectContext.LoadProperty (entity, navigationProperty, mergeOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
        <Parameter Name="navigationProperty" Type="System.String" />
        <Parameter Name="mergeOption" Type="System.Data.Entity.Core.Objects.MergeOption" />
      </Parameters>
      <Docs>
        <param name="entity">The entity for which related objects are to be loaded.</param>
        <param name="navigationProperty">The name of the navigation property that returns the related objects to be loaded.</param>
        <param name="mergeOption">
            The <see cref="T:System.Data.Entity.Core.Objects.MergeOption" /> value to use when you load the related objects.
            </param>
        <summary>Explicitly loads an object that is related to the supplied object by the specified navigation property and using the specified merge option. </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">
            The  entity  is in a <see cref="F:System.Data.Entity.EntityState.Detached" />,
            <see cref="F:System.Data.Entity.EntityState.Added," />
            or <see cref="F:System.Data.Entity.EntityState.Deleted" /> state or the  entity  is attached to another instance of
            <see cref="T:System.Data.Entity.Core.Objects.ObjectContext" />
            .
            </exception>
      </Docs>
    </Member>
    <Member MemberName="LoadProperty&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public virtual void LoadProperty&lt;TEntity&gt; (TEntity entity, System.Linq.Expressions.Expression&lt;Func&lt;TEntity,object&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LoadProperty&lt;TEntity&gt;(!!TEntity entity, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TEntity, object&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.LoadProperty``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub LoadProperty(Of TEntity) (entity As TEntity, selector As Expression(Of Func(Of TEntity, Object)))" />
      <MemberSignature Language="F#" Value="abstract member LoadProperty : 'Entity * System.Linq.Expressions.Expression&lt;Func&lt;'Entity, obj&gt;&gt; -&gt; unit&#xA;override this.LoadProperty : 'Entity * System.Linq.Expressions.Expression&lt;Func&lt;'Entity, obj&gt;&gt; -&gt; unit" Usage="objectContext.LoadProperty (entity, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TEntity,System.Object&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">The type of the entity.</typeparam>
        <param name="entity">The source object for which related objects are to be loaded.</param>
        <param name="selector">A LINQ expression that defines the related objects to be loaded.</param>
        <summary>Explicitly loads an object that is related to the supplied object by the specified LINQ query and by using the default merge option. </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"> selector  does not supply a valid input parameter.</exception>
        <exception cref="T:System.ArgumentNullException"> selector  is null.</exception>
        <exception cref="T:System.InvalidOperationException">
            The  entity  is in a <see cref="F:System.Data.Entity.EntityState.Detached" />,
            <see cref="F:System.Data.Entity.EntityState.Added," />
            or <see cref="F:System.Data.Entity.EntityState.Deleted" /> state or the  entity  is attached to another instance of
            <see cref="T:System.Data.Entity.Core.Objects.ObjectContext" />
            .
            </exception>
      </Docs>
    </Member>
    <Member MemberName="LoadProperty&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public virtual void LoadProperty&lt;TEntity&gt; (TEntity entity, System.Linq.Expressions.Expression&lt;Func&lt;TEntity,object&gt;&gt; selector, System.Data.Entity.Core.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LoadProperty&lt;TEntity&gt;(!!TEntity entity, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TEntity, object&gt;&gt; selector, valuetype System.Data.Entity.Core.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.LoadProperty``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.Data.Entity.Core.Objects.MergeOption)" />
      <MemberSignature Language="F#" Value="abstract member LoadProperty : 'Entity * System.Linq.Expressions.Expression&lt;Func&lt;'Entity, obj&gt;&gt; * System.Data.Entity.Core.Objects.MergeOption -&gt; unit&#xA;override this.LoadProperty : 'Entity * System.Linq.Expressions.Expression&lt;Func&lt;'Entity, obj&gt;&gt; * System.Data.Entity.Core.Objects.MergeOption -&gt; unit" Usage="objectContext.LoadProperty (entity, selector, mergeOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TEntity,System.Object&gt;&gt;" />
        <Parameter Name="mergeOption" Type="System.Data.Entity.Core.Objects.MergeOption" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">The type of the entity.</typeparam>
        <param name="entity">The source object for which related objects are to be loaded.</param>
        <param name="selector">A LINQ expression that defines the related objects to be loaded.</param>
        <param name="mergeOption">
            The <see cref="T:System.Data.Entity.Core.Objects.MergeOption" /> value to use when you load the related objects.
            </param>
        <summary>Explicitly loads an object that is related to the supplied object by the specified LINQ query and by using the specified merge option. </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"> selector  does not supply a valid input parameter.</exception>
        <exception cref="T:System.ArgumentNullException"> selector  is null.</exception>
        <exception cref="T:System.InvalidOperationException">
            The  entity  is in a <see cref="F:System.Data.Entity.EntityState.Detached" />,
            <see cref="F:System.Data.Entity.EntityState.Added," />
            or <see cref="F:System.Data.Entity.EntityState.Deleted" /> state or the  entity  is attached to another instance of
            <see cref="T:System.Data.Entity.Core.Objects.ObjectContext" />
            .
            </exception>
      </Docs>
    </Member>
    <Member MemberName="MetadataWorkspace">
      <MemberSignature Language="C#" Value="public virtual System.Data.Entity.Core.Metadata.Edm.MetadataWorkspace MetadataWorkspace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Entity.Core.Metadata.Edm.MetadataWorkspace MetadataWorkspace" />
      <MemberSignature Language="DocId" Value="P:System.Data.Entity.Core.Objects.ObjectContext.MetadataWorkspace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MetadataWorkspace As MetadataWorkspace" />
      <MemberSignature Language="F#" Value="member this.MetadataWorkspace : System.Data.Entity.Core.Metadata.Edm.MetadataWorkspace" Usage="System.Data.Entity.Core.Objects.ObjectContext.MetadataWorkspace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Entity.Core.Metadata.Edm.MetadataWorkspace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the metadata workspace used by the object context. </summary>
        <value>
            The <see cref="T:System.Data.Entity.Core.Metadata.Edm.MetadataWorkspace" /> object associated with this
            <see cref="T:System.Data.Entity.Core.Objects.ObjectContext" />
            .
            </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ObjectMaterialized">
      <MemberSignature Language="C#" Value="public event System.Data.Entity.Core.Objects.ObjectMaterializedEventHandler ObjectMaterialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.Entity.Core.Objects.ObjectMaterializedEventHandler ObjectMaterialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.Entity.Core.Objects.ObjectContext.ObjectMaterialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ObjectMaterialized As ObjectMaterializedEventHandler " />
      <MemberSignature Language="F#" Value="member this.ObjectMaterialized : System.Data.Entity.Core.Objects.ObjectMaterializedEventHandler " Usage="member this.ObjectMaterialized : System.Data.Entity.Core.Objects.ObjectMaterializedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Entity.Core.Objects.ObjectMaterializedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a new entity object is created from data in the data source as part of a query or load operation. </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ObjectStateManager">
      <MemberSignature Language="C#" Value="public virtual System.Data.Entity.Core.Objects.ObjectStateManager ObjectStateManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Entity.Core.Objects.ObjectStateManager ObjectStateManager" />
      <MemberSignature Language="DocId" Value="P:System.Data.Entity.Core.Objects.ObjectContext.ObjectStateManager" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ObjectStateManager As ObjectStateManager" />
      <MemberSignature Language="F#" Value="member this.ObjectStateManager : System.Data.Entity.Core.Objects.ObjectStateManager" Usage="System.Data.Entity.Core.Objects.ObjectContext.ObjectStateManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Entity.Core.Objects.ObjectStateManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the object state manager used by the object context to track object changes.</summary>
        <value>
            The <see cref="T:System.Data.Entity.Core.Objects.ObjectStateManager" /> used by this
            <see cref="T:System.Data.Entity.Core.Objects.ObjectContext" />
            .
            </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryProvider">
      <MemberSignature Language="C#" Value="protected internal virtual System.Linq.IQueryProvider QueryProvider { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Linq.IQueryProvider QueryProvider" />
      <MemberSignature Language="DocId" Value="P:System.Data.Entity.Core.Objects.ObjectContext.QueryProvider" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property QueryProvider As IQueryProvider" />
      <MemberSignature Language="F#" Value="member this.QueryProvider : System.Linq.IQueryProvider" Usage="System.Data.Entity.Core.Objects.ObjectContext.QueryProvider" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the LINQ query provider associated with this object context.</summary>
        <value>
            The <see cref="T:System.Linq.IQueryProvider" /> instance used by this object context.
            </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public virtual void Refresh (System.Data.Entity.Core.Objects.RefreshMode refreshMode, System.Collections.IEnumerable collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Refresh(valuetype System.Data.Entity.Core.Objects.RefreshMode refreshMode, class System.Collections.IEnumerable collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.Refresh(System.Data.Entity.Core.Objects.RefreshMode,System.Collections.IEnumerable)" />
      <MemberSignature Language="F#" Value="abstract member Refresh : System.Data.Entity.Core.Objects.RefreshMode * System.Collections.IEnumerable -&gt; unit&#xA;override this.Refresh : System.Data.Entity.Core.Objects.RefreshMode * System.Collections.IEnumerable -&gt; unit" Usage="objectContext.Refresh (refreshMode, collection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="refreshMode" Type="System.Data.Entity.Core.Objects.RefreshMode" />
        <Parameter Name="collection" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="refreshMode">
            A <see cref="T:System.Data.Entity.Core.Objects.RefreshMode" /> value that indicates whether 
            property changes in the object context are overwritten with property values from the database.
            </param>
        <param name="collection">
            An <see cref="T:System.Collections.IEnumerable" /> collection of objects to refresh.
            </param>
        <summary>Updates a collection of objects in the object context with data from the database. </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"> collection  is null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"> refreshMode  is not valid.</exception>
        <exception cref="T:System.ArgumentException"> collection is empty or an object is not attached to the context. </exception>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public virtual void Refresh (System.Data.Entity.Core.Objects.RefreshMode refreshMode, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Refresh(valuetype System.Data.Entity.Core.Objects.RefreshMode refreshMode, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.Refresh(System.Data.Entity.Core.Objects.RefreshMode,System.Object)" />
      <MemberSignature Language="F#" Value="abstract member Refresh : System.Data.Entity.Core.Objects.RefreshMode * obj -&gt; unit&#xA;override this.Refresh : System.Data.Entity.Core.Objects.RefreshMode * obj -&gt; unit" Usage="objectContext.Refresh (refreshMode, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="refreshMode" Type="System.Data.Entity.Core.Objects.RefreshMode" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="refreshMode">
            A <see cref="T:System.Data.Entity.Core.Objects.RefreshMode" /> value that indicates whether 
            property changes in the object context are overwritten with property values from the database.
            </param>
        <param name="entity">The object to be refreshed. </param>
        <summary>Updates an object in the object context with data from the database. </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"> entity  is null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"> refreshMode  is not valid.</exception>
        <exception cref="T:System.ArgumentException"> entity is not attached to the context. </exception>
      </Docs>
    </Member>
    <Member MemberName="RefreshAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task RefreshAsync (System.Data.Entity.Core.Objects.RefreshMode refreshMode, System.Collections.IEnumerable collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task RefreshAsync(valuetype System.Data.Entity.Core.Objects.RefreshMode refreshMode, class System.Collections.IEnumerable collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.RefreshAsync(System.Data.Entity.Core.Objects.RefreshMode,System.Collections.IEnumerable)" />
      <MemberSignature Language="F#" Value="member this.RefreshAsync : System.Data.Entity.Core.Objects.RefreshMode * System.Collections.IEnumerable -&gt; System.Threading.Tasks.Task" Usage="objectContext.RefreshAsync (refreshMode, collection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="refreshMode" Type="System.Data.Entity.Core.Objects.RefreshMode" />
        <Parameter Name="collection" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="refreshMode">
            A <see cref="T:System.Data.Entity.Core.Objects.RefreshMode" /> value that indicates whether 
            property changes in the object context are overwritten with property values from the database.
            </param>
        <param name="collection">
            An <see cref="T:System.Collections.IEnumerable" /> collection of objects to refresh.
            </param>
        <summary>Asynchronously updates a collection of objects in the object context with data from the database. </summary>
        <returns>
            A task that represents the asynchronous operation.
            </returns>
        <remarks>
            Multiple active operations on the same context instance are not supported.  Use 'await' to ensure
            that any asynchronous operations have completed before calling another method on this context.
            </remarks>
        <exception cref="T:System.ArgumentNullException"> collection  is null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"> refreshMode  is not valid.</exception>
        <exception cref="T:System.ArgumentException"> collection is empty or an object is not attached to the context. </exception>
      </Docs>
    </Member>
    <Member MemberName="RefreshAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task RefreshAsync (System.Data.Entity.Core.Objects.RefreshMode refreshMode, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task RefreshAsync(valuetype System.Data.Entity.Core.Objects.RefreshMode refreshMode, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.RefreshAsync(System.Data.Entity.Core.Objects.RefreshMode,System.Object)" />
      <MemberSignature Language="F#" Value="member this.RefreshAsync : System.Data.Entity.Core.Objects.RefreshMode * obj -&gt; System.Threading.Tasks.Task" Usage="objectContext.RefreshAsync (refreshMode, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="refreshMode" Type="System.Data.Entity.Core.Objects.RefreshMode" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="refreshMode">
            A <see cref="T:System.Data.Entity.Core.Objects.RefreshMode" /> value that indicates whether 
            property changes in the object context are overwritten with property values from the database.
            </param>
        <param name="entity">The object to be refreshed. </param>
        <summary>Asynchronously updates an object in the object context with data from the database. </summary>
        <returns>
            A task that represents the asynchronous operation.
            </returns>
        <remarks>
            Multiple active operations on the same context instance are not supported.  Use 'await' to ensure
            that any asynchronous operations have completed before calling another method on this context.
            </remarks>
        <exception cref="T:System.ArgumentNullException"> entity  is null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"> refreshMode  is not valid.</exception>
        <exception cref="T:System.ArgumentException"> entity is not attached to the context. </exception>
      </Docs>
    </Member>
    <Member MemberName="RefreshAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task RefreshAsync (System.Data.Entity.Core.Objects.RefreshMode refreshMode, System.Collections.IEnumerable collection, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task RefreshAsync(valuetype System.Data.Entity.Core.Objects.RefreshMode refreshMode, class System.Collections.IEnumerable collection, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.RefreshAsync(System.Data.Entity.Core.Objects.RefreshMode,System.Collections.IEnumerable,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member RefreshAsync : System.Data.Entity.Core.Objects.RefreshMode * System.Collections.IEnumerable * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&#xA;override this.RefreshAsync : System.Data.Entity.Core.Objects.RefreshMode * System.Collections.IEnumerable * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="objectContext.RefreshAsync (refreshMode, collection, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="refreshMode" Type="System.Data.Entity.Core.Objects.RefreshMode" />
        <Parameter Name="collection" Type="System.Collections.IEnumerable" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="refreshMode">
            A <see cref="T:System.Data.Entity.Core.Objects.RefreshMode" /> value that indicates whether 
            property changes in the object context are overwritten with property values from the database.
            </param>
        <param name="collection">
            An <see cref="T:System.Collections.IEnumerable" /> collection of objects to refresh.
            </param>
        <param name="cancellationToken">
            A <see cref="T:System.Threading.CancellationToken" /> to observe while waiting for the task to complete.
            </param>
        <summary>Asynchronously updates a collection of objects in the object context with data from the database. </summary>
        <returns>
            A task that represents the asynchronous operation.
            </returns>
        <remarks>
            Multiple active operations on the same context instance are not supported.  Use 'await' to ensure
            that any asynchronous operations have completed before calling another method on this context.
            </remarks>
        <exception cref="T:System.ArgumentNullException"> collection  is null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"> refreshMode  is not valid.</exception>
        <exception cref="T:System.ArgumentException"> collection is empty or an object is not attached to the context. </exception>
      </Docs>
    </Member>
    <Member MemberName="RefreshAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task RefreshAsync (System.Data.Entity.Core.Objects.RefreshMode refreshMode, object entity, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task RefreshAsync(valuetype System.Data.Entity.Core.Objects.RefreshMode refreshMode, object entity, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.RefreshAsync(System.Data.Entity.Core.Objects.RefreshMode,System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member RefreshAsync : System.Data.Entity.Core.Objects.RefreshMode * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&#xA;override this.RefreshAsync : System.Data.Entity.Core.Objects.RefreshMode * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="objectContext.RefreshAsync (refreshMode, entity, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="refreshMode" Type="System.Data.Entity.Core.Objects.RefreshMode" />
        <Parameter Name="entity" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="refreshMode">
            A <see cref="T:System.Data.Entity.Core.Objects.RefreshMode" /> value that indicates whether 
            property changes in the object context are overwritten with property values from the database.
            </param>
        <param name="entity">The object to be refreshed. </param>
        <param name="cancellationToken">
            A <see cref="T:System.Threading.CancellationToken" /> to observe while waiting for the task to complete.
            </param>
        <summary>Asynchronously updates an object in the object context with data from the database. </summary>
        <returns>
            A task that represents the asynchronous operation.
            </returns>
        <remarks>
            Multiple active operations on the same context instance are not supported.  Use 'await' to ensure
            that any asynchronous operations have completed before calling another method on this context.
            </remarks>
        <exception cref="T:System.ArgumentNullException"> entity  is null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"> refreshMode  is not valid.</exception>
        <exception cref="T:System.ArgumentException"> entity is not attached to the context. </exception>
      </Docs>
    </Member>
    <Member MemberName="SaveChanges">
      <MemberSignature Language="C#" Value="public virtual int SaveChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 SaveChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.SaveChanges" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SaveChanges () As Integer" />
      <MemberSignature Language="F#" Value="abstract member SaveChanges : unit -&gt; int&#xA;override this.SaveChanges : unit -&gt; int" Usage="objectContext.SaveChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Persists all updates to the database and resets change tracking in the object context.</summary>
        <returns>
            The number of state entries written to the underlying database. This can include
            state entries for entities and/or relationships. Relationship state entries are created for 
            many-to-many relationships and relationships where there is no foreign key property
            included in the entity class (often referred to as independent associations).
            </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Data.Entity.Core.OptimisticConcurrencyException">An optimistic concurrency violation has occurred while saving changes.</exception>
      </Docs>
    </Member>
    <Member MemberName="SaveChanges">
      <MemberSignature Language="C#" Value="public virtual int SaveChanges (bool acceptChangesDuringSave);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 SaveChanges(bool acceptChangesDuringSave) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.SaveChanges(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SaveChanges (acceptChangesDuringSave As Boolean) As Integer" />
      <MemberSignature Language="F#" Value="abstract member SaveChanges : bool -&gt; int&#xA;override this.SaveChanges : bool -&gt; int" Usage="objectContext.SaveChanges acceptChangesDuringSave" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use SaveChanges(SaveOptions options) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptChangesDuringSave" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="acceptChangesDuringSave">
            This parameter is needed for client-side transaction support. If true, the change tracking on all objects is reset after
            <see cref="M:System.Data.Entity.Core.Objects.ObjectContext.SaveChanges(System.Boolean)" />
            finishes. If false, you must call the <see cref="M:System.Data.Entity.Core.Objects.ObjectContext.AcceptAllChanges" />
            method after <see cref="M:System.Data.Entity.Core.Objects.ObjectContext.SaveChanges(System.Boolean)" />.
            </param>
        <summary>Persists all updates to the database and optionally resets change tracking in the object context.</summary>
        <returns>
            The number of state entries written to the underlying database. This can include
            state entries for entities and/or relationships. Relationship state entries are created for 
            many-to-many relationships and relationships where there is no foreign key property
            included in the entity class (often referred to as independent associations).
            </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Data.Entity.Core.OptimisticConcurrencyException">An optimistic concurrency violation has occurred while saving changes.</exception>
      </Docs>
    </Member>
    <Member MemberName="SaveChanges">
      <MemberSignature Language="C#" Value="public virtual int SaveChanges (System.Data.Entity.Core.Objects.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 SaveChanges(valuetype System.Data.Entity.Core.Objects.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.SaveChanges(System.Data.Entity.Core.Objects.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SaveChanges (options As SaveOptions) As Integer" />
      <MemberSignature Language="F#" Value="abstract member SaveChanges : System.Data.Entity.Core.Objects.SaveOptions -&gt; int&#xA;override this.SaveChanges : System.Data.Entity.Core.Objects.SaveOptions -&gt; int" Usage="objectContext.SaveChanges options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Data.Entity.Core.Objects.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="options">
            A <see cref="T:System.Data.Entity.Core.Objects.SaveOptions" /> value that determines the behavior of the operation.
            </param>
        <summary>Persists all updates to the database and optionally resets change tracking in the object context.</summary>
        <returns>
            The number of state entries written to the underlying database. This can include
            state entries for entities and/or relationships. Relationship state entries are created for 
            many-to-many relationships and relationships where there is no foreign key property
            included in the entity class (often referred to as independent associations).
            </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Data.Entity.Core.OptimisticConcurrencyException">An optimistic concurrency violation has occurred while saving changes.</exception>
      </Docs>
    </Member>
    <Member MemberName="SaveChangesAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; SaveChangesAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; SaveChangesAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.SaveChangesAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SaveChangesAsync () As Task(Of Integer)" />
      <MemberSignature Language="F#" Value="abstract member SaveChangesAsync : unit -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.SaveChangesAsync : unit -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="objectContext.SaveChangesAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronously persists all updates to the database and resets change tracking in the object context.</summary>
        <returns>
            A task that represents the asynchronous save operation.
            The task result contains the number of state entries written to the underlying database. This can include
            state entries for entities and/or relationships. Relationship state entries are created for 
            many-to-many relationships and relationships where there is no foreign key property
            included in the entity class (often referred to as independent associations).
            </returns>
        <remarks>
            Multiple active operations on the same context instance are not supported.  Use 'await' to ensure
            that any asynchronous operations have completed before calling another method on this context.
            </remarks>
        <exception cref="T:System.Data.Entity.Core.OptimisticConcurrencyException">An optimistic concurrency violation has occurred while saving changes.</exception>
      </Docs>
    </Member>
    <Member MemberName="SaveChangesAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; SaveChangesAsync (System.Data.Entity.Core.Objects.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; SaveChangesAsync(valuetype System.Data.Entity.Core.Objects.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.SaveChangesAsync(System.Data.Entity.Core.Objects.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SaveChangesAsync (options As SaveOptions) As Task(Of Integer)" />
      <MemberSignature Language="F#" Value="abstract member SaveChangesAsync : System.Data.Entity.Core.Objects.SaveOptions -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.SaveChangesAsync : System.Data.Entity.Core.Objects.SaveOptions -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="objectContext.SaveChangesAsync options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Data.Entity.Core.Objects.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="options">
            A <see cref="T:System.Data.Entity.Core.Objects.SaveOptions" /> value that determines the behavior of the operation.
            </param>
        <summary>Asynchronously persists all updates to the database and optionally resets change tracking in the object context.</summary>
        <returns>
            A task that represents the asynchronous save operation.
            The task result contains the number of state entries written to the underlying database. This can include
            state entries for entities and/or relationships. Relationship state entries are created for 
            many-to-many relationships and relationships where there is no foreign key property
            included in the entity class (often referred to as independent associations).
            </returns>
        <remarks>
            Multiple active operations on the same context instance are not supported.  Use 'await' to ensure
            that any asynchronous operations have completed before calling another method on this context.
            </remarks>
        <exception cref="T:System.Data.Entity.Core.OptimisticConcurrencyException">An optimistic concurrency violation has occurred while saving changes.</exception>
      </Docs>
    </Member>
    <Member MemberName="SaveChangesAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; SaveChangesAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; SaveChangesAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.SaveChangesAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member SaveChangesAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.SaveChangesAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="objectContext.SaveChangesAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">
            A <see cref="T:System.Threading.CancellationToken" /> to observe while waiting for the task to complete.
            </param>
        <summary>Asynchronously persists all updates to the database and resets change tracking in the object context.</summary>
        <returns>
            A task that represents the asynchronous save operation.
            The task result contains the number of state entries written to the underlying database. This can include
            state entries for entities and/or relationships. Relationship state entries are created for 
            many-to-many relationships and relationships where there is no foreign key property
            included in the entity class (often referred to as independent associations).
            </returns>
        <remarks>
            Multiple active operations on the same context instance are not supported.  Use 'await' to ensure
            that any asynchronous operations have completed before calling another method on this context.
            </remarks>
        <exception cref="T:System.Data.Entity.Core.OptimisticConcurrencyException">An optimistic concurrency violation has occurred while saving changes.</exception>
      </Docs>
    </Member>
    <Member MemberName="SaveChangesAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; SaveChangesAsync (System.Data.Entity.Core.Objects.SaveOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; SaveChangesAsync(valuetype System.Data.Entity.Core.Objects.SaveOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.SaveChangesAsync(System.Data.Entity.Core.Objects.SaveOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member SaveChangesAsync : System.Data.Entity.Core.Objects.SaveOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.SaveChangesAsync : System.Data.Entity.Core.Objects.SaveOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="objectContext.SaveChangesAsync (options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Data.Entity.Core.Objects.SaveOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="options">
            A <see cref="T:System.Data.Entity.Core.Objects.SaveOptions" /> value that determines the behavior of the operation.
            </param>
        <param name="cancellationToken">
            A <see cref="T:System.Threading.CancellationToken" /> to observe while waiting for the task to complete.
            </param>
        <summary>Asynchronously persists all updates to the database and optionally resets change tracking in the object context.</summary>
        <returns>
            A task that represents the asynchronous save operation.
            The task result contains the number of state entries written to the underlying database. This can include
            state entries for entities and/or relationships. Relationship state entries are created for 
            many-to-many relationships and relationships where there is no foreign key property
            included in the entity class (often referred to as independent associations).
            </returns>
        <remarks>
            Multiple active operations on the same context instance are not supported.  Use 'await' to ensure
            that any asynchronous operations have completed before calling another method on this context.
            </remarks>
        <exception cref="T:System.Data.Entity.Core.OptimisticConcurrencyException">An optimistic concurrency violation has occurred while saving changes.</exception>
      </Docs>
    </Member>
    <Member MemberName="SavingChanges">
      <MemberSignature Language="C#" Value="public event EventHandler SavingChanges;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SavingChanges" />
      <MemberSignature Language="DocId" Value="E:System.Data.Entity.Core.Objects.ObjectContext.SavingChanges" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SavingChanges As EventHandler " />
      <MemberSignature Language="F#" Value="member this.SavingChanges : EventHandler " Usage="member this.SavingChanges : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when changes are saved to the data source. </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.Entity.Infrastructure.IObjectContextAdapter.ObjectContext">
      <MemberSignature Language="C#" Value="System.Data.Entity.Core.Objects.ObjectContext System.Data.Entity.Infrastructure.IObjectContextAdapter.ObjectContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Entity.Core.Objects.ObjectContext System.Data.Entity.Infrastructure.IObjectContextAdapter.ObjectContext" />
      <MemberSignature Language="DocId" Value="P:System.Data.Entity.Core.Objects.ObjectContext.System#Data#Entity#Infrastructure#IObjectContextAdapter#ObjectContext" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ObjectContext As ObjectContext Implements IObjectContextAdapter.ObjectContext" />
      <MemberSignature Language="F#" Usage="System.Data.Entity.Infrastructure.IObjectContextAdapter.ObjectContext" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.Entity.Infrastructure.IObjectContextAdapter.ObjectContext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1033:InterfaceMethodsShouldBeCallableByChildTypes")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Entity.Core.Objects.ObjectContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Returns itself. ObjectContext implements <see cref="T:System.Data.Entity.Infrastructure.IObjectContextAdapter" /> to provide a common
            interface for <see cref="T:System.Data.Entity.DbContext" /> and ObjectContext both of which will return the underlying
            ObjectContext.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransactionHandler">
      <MemberSignature Language="C#" Value="public System.Data.Entity.Infrastructure.TransactionHandler TransactionHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Entity.Infrastructure.TransactionHandler TransactionHandler" />
      <MemberSignature Language="DocId" Value="P:System.Data.Entity.Core.Objects.ObjectContext.TransactionHandler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransactionHandler As TransactionHandler" />
      <MemberSignature Language="F#" Value="member this.TransactionHandler : System.Data.Entity.Infrastructure.TransactionHandler" Usage="System.Data.Entity.Core.Objects.ObjectContext.TransactionHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Entity.Infrastructure.TransactionHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the transaction handler in use by this context. May be null if no transaction have been started.
            </summary>
        <value>
            The transaction handler.
            </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Translate&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public virtual System.Data.Entity.Core.Objects.ObjectResult&lt;TElement&gt; Translate&lt;TElement&gt; (System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.Entity.Core.Objects.ObjectResult`1&lt;!!TElement&gt; Translate&lt;TElement&gt;(class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.Translate``1(System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Translate(Of TElement) (reader As DbDataReader) As ObjectResult(Of TElement)" />
      <MemberSignature Language="F#" Value="abstract member Translate : System.Data.Common.DbDataReader -&gt; System.Data.Entity.Core.Objects.ObjectResult&lt;'Element&gt;&#xA;override this.Translate : System.Data.Common.DbDataReader -&gt; System.Data.Entity.Core.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.Translate reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Entity.Core.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <typeparam name="TElement">The entity type.</typeparam>
        <param name="reader">
            The <see cref="T:System.Data.Common.DbDataReader" /> that contains entity data to translate into entity objects.
            </param>
        <summary>
            Translates a <see cref="T:System.Data.Common.DbDataReader" /> that contains rows of entity data to objects of the requested entity type.
            </summary>
        <returns>An enumeration of objects of type  TResult .</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">When  reader  is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Translate&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public virtual System.Data.Entity.Core.Objects.ObjectResult&lt;TEntity&gt; Translate&lt;TEntity&gt; (System.Data.Common.DbDataReader reader, string entitySetName, System.Data.Entity.Core.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.Entity.Core.Objects.ObjectResult`1&lt;!!TEntity&gt; Translate&lt;TEntity&gt;(class System.Data.Common.DbDataReader reader, string entitySetName, valuetype System.Data.Entity.Core.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.Translate``1(System.Data.Common.DbDataReader,System.String,System.Data.Entity.Core.Objects.MergeOption)" />
      <MemberSignature Language="F#" Value="abstract member Translate : System.Data.Common.DbDataReader * string * System.Data.Entity.Core.Objects.MergeOption -&gt; System.Data.Entity.Core.Objects.ObjectResult&lt;'Entity&gt;&#xA;override this.Translate : System.Data.Common.DbDataReader * string * System.Data.Entity.Core.Objects.MergeOption -&gt; System.Data.Entity.Core.Objects.ObjectResult&lt;'Entity&gt;" Usage="objectContext.Translate (reader, entitySetName, mergeOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1004:GenericMethodsShouldProvideTypeParameter", Justification="Generic parameters are required for strong-typing of the return type.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Entity.Core.Objects.ObjectResult&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="mergeOption" Type="System.Data.Entity.Core.Objects.MergeOption" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">The entity type.</typeparam>
        <param name="reader">
            The <see cref="T:System.Data.Common.DbDataReader" /> that contains entity data to translate into entity objects.
            </param>
        <param name="entitySetName">The entity set of the  TResult  type.</param>
        <param name="mergeOption">
            The <see cref="T:System.Data.Entity.Core.Objects.MergeOption" /> to use when translated objects are added to the object context. The default is
            <see cref="F:System.Data.Entity.Core.Objects.MergeOption.AppendOnly" />
            .
            </param>
        <summary>
            Translates a <see cref="T:System.Data.Common.DbDataReader" /> that contains rows of entity data to objects of the requested entity type, in a specific entity set, and with the specified merge option.
            </summary>
        <returns>An enumeration of objects of type  TResult .</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">When  reader  is null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
            When the supplied  mergeOption  is not a valid <see cref="T:System.Data.Entity.Core.Objects.MergeOption" /> value.
            </exception>
        <exception cref="T:System.InvalidOperationException">When the supplied  entitySetName  is not a valid entity set for the  TResult  type. </exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetObjectByKey">
      <MemberSignature Language="C#" Value="public virtual bool TryGetObjectByKey (System.Data.Entity.Core.EntityKey key, out object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetObjectByKey(class System.Data.Entity.Core.EntityKey key, [out] object&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Entity.Core.Objects.ObjectContext.TryGetObjectByKey(System.Data.Entity.Core.EntityKey,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetObjectByKey (key As EntityKey, ByRef value As Object) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member TryGetObjectByKey : System.Data.Entity.Core.EntityKey *  -&gt; bool&#xA;override this.TryGetObjectByKey : System.Data.Entity.Core.EntityKey *  -&gt; bool" Usage="objectContext.TryGetObjectByKey (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>EntityFramework</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1007:UseGenericsWhereAppropriate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.Entity.Core.EntityKey" />
        <Parameter Name="value" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">The key of the object to be found.</param>
        <param name="value">When this method returns, contains the object.</param>
        <summary>Returns an object that has the specified entity key.</summary>
        <returns>true if the object was retrieved successfully. false if the  key  is temporary, the connection is null, or the  value  is null.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Incompatible metadata for  key .</exception>
        <exception cref="T:System.ArgumentNullException"> key  is null.</exception>
      </Docs>
    </Member>
  </Members>
</Type>